<!DOCTYPE html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><link href="../Styles/MyEBookStylesheet.css" rel="stylesheet" type="text/css" /></head><body>
<h1 id="willkommen">Willkommen</h1>
<p>todo <a href="https://github.com/woota/FE-training-examples/blob/master/es6/4.%20Arrow-Functions.md">https://github.com/woota/FE-training-examples/blob/master/es6/4.%20Arrow-Functions.md</a></p>
<p>todo <a href="https://de.wikipedia.org/wiki/JavaScript">https://de.wikipedia.org/wiki/JavaScript</a></p>
<p>todo Beispiele Meldungen Firfox </p>
<p>todo Vergleich mit ECMAScript 5 - dabei lernt man auch etwas ...</p>
<p>Das Arbeiten mit Geodaten und digitalen Landkarten hat durch das 
<a href="https://de.wikipedia.org/w/index.php?title=Global_Positioning_System&amp;oldid=183579881"><strong>g</strong>lobale <strong>P</strong>ositionsbestimmung<strong>s</strong>system GPS</a><sup id="fnref1:1"><a href="#fn%3A1" class="footnote-ref">1</a></sup> 
immer mehr an Relevanz gewonnen. 
Viele Anwendungen bieten heute sogar online geografische Informationen in Echtzeit an. 
So finden Sie auch im Internet immer mehr digitale Karten und Anwendungen 
die mit Geodaten arbeiten.</p>
<blockquote>
<p><a href="https://de.wikipedia.org/w/index.php?title=Geodaten&amp;oldid=181076558">Geodaten</a><sup id="fnref1:2"><a href="#fn%3A2" class="footnote-ref">2</a></sup> 
sind Informationen, die eine Zuordnung zu einer räumlichen Lage besitzen. 
90 % aller Daten können einem Ort zugeordnet werden und sind somit Geodaten.</p>
</blockquote>
<p>Sie lesen dieses Buch sicherlich, weil Sie mit dem Gedanken spielen eine digitale Karte 
anzubieten - höchstwahrscheinlich auf einer Website. Die Grundlagen zu dem, 
was ich in diesem Buch geschrieben habe, finden Sie alle in der 
<a href="https://leafletjs.com/reference">Dokumentation zu Leaflet</a><sup id="fnref1:3"><a href="#fn%3A3" class="footnote-ref">3</a></sup> - oder zu den 
jeweiligen Plugins - öffentlich im Internet. 
Diese Dokumentationen habe ich hier im Buch verlinkt. Warum habe ich trotzdem 
dieses Buch geschrieben?  </p>
<p>Ich habe das Buch geschrieben, 
weil ich manchmal gerne mit Beispielen lerne. Oft komme ich hierbei auf Ideen, 
die trockene Dokumentationen nicht hergeben. Vielleicht geht es Ihnen ja auch 
so und dieses Buch bringt Ihnen einen Mehrwert zu den vorhandenen Dokumentationen. 
Die Quellcode-Dateien zu den im Buch verwendeten Beispielen finden Sie auf der 
Website <a href="https://astrid-guenther.de">https://astrid-guenther.de</a>.</p>
<p>Außerdem finde ich es immer sehr hilfreich, wenn ich ein bisschen über den 
Tellerrand hinaus blicke. Hier im Buch finden Sie ein paar solcher Blicke. 
Wenn es Sie interessiert, können Sie mit mir etwas tiefer in die Welt der 
geografische Koordinaten blicken. Ich erkläre Ihnen auch die unterschiedlichen 
Techniken beim Erstellen der Grafiken für die digitalen Karten. 
Außerdem sehe ich mir mit Ihnen GeoJSON, über die reine Anwendung hinaus, 
etwas genauer an. Ich zeigen Ihnen wie Sie der Karte mit individuellen Markern 
eine persönliche Note geben können. Neben diesen grundlegenden Elementen kommen 
die Visualisierung der Daten mit Heatmaps, Geocoding und Routing nicht zu kurz.</p>
<h2 id="wichtiges-zum-buch">Wichtiges zum Buch</h2>
<p>Ich erkläre Ihnen hier Schritt für Schritt alles das, was ich rund um Leaflet 
als wichtig ansehe – also alles das, was Sie als Entwickler brauchen, um kreativ 
arbeiten zu können.</p>
<p>Ich hoffe, dass Ihnen meine Art zu schreiben gefällt. Ich persönlich hätte mir 
genau dieses Buch zum Start mit Leaflet gewünscht.</p>
<h2 id="was-ist-leaflet">Was ist Leaflet?</h2>
<p><a href="https://leafletjs.com/reference">Leaflet</a> ist eine 
Open Source <a href="https://de.wikipedia.org/w/index.php?title=JavaScript_Object_Notation&amp;oldid=183718070">JavaScript</a>-Bibliothek<sup id="fnref1:4"><a href="#fn%3A4" class="footnote-ref">4</a></sup>, 
die Ihnen das 
Bereitstellen von Karten auf Ihrer Webseite einfach macht. 
<a href="https://www.bsi-fuer-buerger.de/BSIFB/DE/Empfehlungen/EinrichtungSoftware/OpenSource/OpenSource.html">Open Source</a><sup id="fnref1:5"><a href="#fn%3A5" class="footnote-ref">5</a></sup> 
bedeutet unter anderem, dass der Programmcode einsehbar ist. 
Jeder mit den notwendigen Kenntnissen kann prüfen, wie die Anwendung genau 
funktioniert. Und was noch wichtiger ist: Jeder kann Leaflet verwenden, 
an seine Bedürfnisse anpassen und verbessern.</p>
<p>Was müssen Sie tun, wenn Sie Leaflet auf Ihrer Website einsetzen möchten? 
Im Grunde genommen müssen Sie nur zwei Dateien – eine JavaScript Datei und die 
dazugehörige CSS-Datei einbinden. Wie Sie das genau machen erkläre ich Ihnen 
im Kapitel <a href="../eine-erste-karte/wir-beginnen-mit-einer-einfachen-karte#IntegrierenSiedienotwendigenJavaScriptundCascadingStyleSheet">Integrieren Sie die notwendigen JavaScript und Cascading Style Sheet 
(CSS) Dateien</a> 
ganz genau.</p>
<p>Das Einbinden der Dateien bietet Ihnen den Zugriff auf eine Reihe von Funktionen. Mithilfe dieser Funktionen können sie unkompliziert eine digitale Karte auf Ihrer Website integrieren. Leaflet unterstützt alle modernen Browser – auch die mobilen Versionen. Das bedeute, dass Sie Ihre Karte so ziemlich überall einsetzen können.</p>
<p>Leaflet selbst legt den Schwerpunkt auf die einfache Bedienbarkeit und die Performance. Außerdem ist es den Entwicklern von Leaflet wichtig, dass die JavaScript Bibliothek unkompliziert von anderen Entwicklern mit einem Plugin erweitert werden kann. Die Programmierschnittstelle ist sehr gut dokumentiert. Als Erweiterungsprogrammierer muss man keine Geheimnisse lüften, um Leaflet erfolgreich mit einem Plugin zu erweitern. Dies ist meiner Meinung nach eine der bedeutendsten Stärken von Leaflet.</p>
<p>Viele namhafte Unternehmen setzten Leaflet ein. 
Darunter sind Namen wie </p>
<ul>
<li><a href="https://www.flickr.com">Flickr</a>, </li>
<li><a href="https://github.com/">Github</a>, </li>
<li><a href="https://www.pinterest.com/">Pinterest</a>, </li>
<li><a href="https://www.wikimedia.de/">Wikimedia</a> und </li>
<li><a href="http://www.spiegel.de/">Spiegel</a>.</li>
</ul>
<p>Out-of-the-box können Sie mit Leaflet Marker, Popups, Linien und Formen auf 
unterschiedlichen Ebenen auf Ihrer Karte anzeigen. 
Sie können Zoomen, Entfernungen berechnen und das Zentrum der Karte zu 
bestimmten Koordinaten schieben.</p>
<h2 id="was-sollten-sie-mitbringen">Was sollten Sie mitbringen?</h2>
<p>Ich gehe davon aus, dass Sie über grundlegende <a href="https://de.wikipedia.org/w/index.php?title=HTML5&amp;oldid=182888530">HTML</a><sup id="fnref1:6"><a href="#fn%3A6" class="footnote-ref">6</a></sup> 
und <a href="https://de.wikipedia.org/w/index.php?title=Cascading_Style_Sheets&amp;oldid=181828388">CSS</a><sup id="fnref1:7"><a href="#fn%3A7" class="footnote-ref">7</a></sup> 
Kenntnisse verfügen. 
Sie sollten auf alle Fälle wissen, wie Sie CSS und ein 
<a href="https://de.wikipedia.org/w/index.php?title=JavaScript_Object_Notation&amp;oldid=183718070">JavaScript</a>-Skript 
in ein HTML-Dokument einbinden und wie Sie mit einfachen HTML-Elementen 
arbeiten. </p>
<blockquote>
<p><a href="http://www.w3.org/Style/CSS/">CSS</a>
ist eine Stylesheet-Sprache für digitale Dokumente. Stylesheet-Sprachen werden
verwendet, um Dokumente und Benutzeroberflächen zu gestalten. Dabei ist ein
Stylesheet mit einer <a href="https://de.wikipedia.org/w/index.php?title=Formatvorlage&amp;oldid=183843814">Formatvorlage</a><sup id="fnref1:8"><a href="#fn%3A8" class="footnote-ref">8</a></sup> zu
vergleichen. Grundidee hierbei ist die Trennung von Dateninhalten und Design.
Zusammen mit HTML und dem <a href="https://wiki.selfhtml.org/index.php?title=JavaScript/DOM&amp;oldid=61063">DOM</a><sup id="fnref1:9"><a href="#fn%3A9" class="footnote-ref">9</a></sup> ist CSS
eines der wichtigsten Elemente im Internet. CSS ist ein so genannter lebendiger 
Standard und wird vom <a href="https://www.w3.org/">W3C</a><sup id="fnref1:10"><a href="#fn%3A10" class="footnote-ref">10</a></sup> und dem <a href="https://whatwg.org/">WHATWG</a><sup id="fnref1:11"><a href="#fn%3A11" class="footnote-ref">11</a></sup> permanent 
weiterentwickelt.  </p>
</blockquote>
<p>. </p>
<blockquote>
<p><a href="https://de.wikipedia.org/w/index.php?title=HTML5&amp;oldid=182888530">HTML</a><sup id="fnref1:12"><a href="#fn%3A12" class="footnote-ref">12</a></sup> 
ist eine textbasierte Auszeichnungssprache zur Strukturierung digitaler 
Dokumente wie Texte mit Hyperlinks, Bildern und anderen Inhalten. HTML-Dokumente 
sind die Grundlage des World Wide Web und werden von Webbrowsern dargestellt.</p>
</blockquote>
<p>Für das Verständnis der Beispiele sind darüber hinaus grundlegende <a href="https://de.wikipedia.org/w/index.php?title=JavaScript_Object_Notation&amp;oldid=183718070">JavaScript</a><sup id="fnref1:13"><a href="#fn%3A13" class="footnote-ref">13</a></sup> 
Kenntnisse hilfreich. Für die Entwicklung dynamischer Webseiten ist JavaScript unerlässlich. </p>
<blockquote>
<p>Mit <a href="https://de.wikipedia.org/w/index.php?title=JavaScript_Object_Notation&amp;oldid=183718070">JavaScript</a><sup id="fnref1:14"><a href="#fn%3A14" class="footnote-ref">14</a></sup> 
lassen sich kleine Hilfsroutinen und auch komplexen Bibliotheken schreiben. </p>
</blockquote>
<h2 id="die-autorin">Die Autorin</h2>
<p>Ich habe über 30 Jahre im öffentlichen Dienst gearbeitet. Die meiste Zeit 
als Systemadministratorin in einer Bank.  </p>
<p>In dieser Zeit habe ich nebenberuflich das Abitur nachgeholt und im 
Anschluss ein Studium mit dem Abschluss Master of Computer Science bei der 
Fernuni Hagen abgeschlossen.  </p>
<p>Heute arbeite ich freiberuflich unter anderem mit Leaflet, lebe mit 
meinem Mann, meiner Tochter, meinem Hund und meiner Katze in einem kleinen Dorf 
in der Eifel.  </p>
<p>Fragen zum Buch, konstruktive Kritik, Anregungen und Hinweise auf Tippfehler können 
gerne per E-Mail an die E-Mail-Adresse 
<a href="mailto:info@astrid-guenther.de">info@astrid-guenther.de</a> gesandt werden.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn:1">
<p><a href="https://de.wikipedia.org/w/index.php?title=Global_Positioning_System&amp;oldid=183579881">https://de.wikipedia.org/w/index.php?title=Global_Positioning_System&amp;oldid=183579881</a> (<a href="https://bit.ly/2Rko7MC">https://bit.ly/2Rko7MC</a>) &#160;<a href="#fnref1%3A1" rev="footnote" class="footnote-backref">&#8617;</a></p>
</li>
<li id="fn:2">
<p><a href="https://de.wikipedia.org/w/index.php?title=Geodaten&amp;oldid=181076558">https://de.wikipedia.org/w/index.php?title=Geodaten&amp;oldid=181076558</a> (<a href="https://bit.ly/2RkeBZT">https://bit.ly/2RkeBZT</a>)&#160;<a href="#fnref1%3A2" rev="footnote" class="footnote-backref">&#8617;</a></p>
</li>
<li id="fn:3">
<p><a href="https://leafletjs.com/reference">https://leafletjs.com/reference</a>&#160;<a href="#fnref1%3A3" rev="footnote" class="footnote-backref">&#8617;</a></p>
</li>
<li id="fn:4">
<p><a href="https://de.wikipedia.org/w/index.php?title=JavaScript_Object_Notation&amp;oldid=183718070">https://de.wikipedia.org/w/index.php?title=JavaScript_Object_Notation&amp;oldid=183718070</a> (<a href="https://bit.ly/2Tc84hc">https://bit.ly/2Tc84hc</a>)&#160;<a href="#fnref1%3A4" rev="footnote" class="footnote-backref">&#8617;</a></p>
</li>
<li id="fn:5">
<p><a href="https://www.bsi-fuer-buerger.de/BSIFB/DE/Empfehlungen/EinrichtungSoftware/OpenSource/OpenSource.html">https://www.bsi-fuer-buerger.de/BSIFB/DE/Empfehlungen/EinrichtungSoftware/OpenSource/OpenSource.html</a> (<a href="https://bit.ly/2EWuWNB">https://bit.ly/2EWuWNB</a>)&#160;<a href="#fnref1%3A5" rev="footnote" class="footnote-backref">&#8617;</a></p>
</li>
<li id="fn:6">
<p><a href="https://de.wikipedia.org/w/index.php?title=HTML5&amp;oldid=182888530">https://de.wikipedia.org/w/index.php?title=HTML5&amp;oldid=182888530</a> (<a href="https://bit.ly/2GMpjnY">https://bit.ly/2GMpjnY</a>)&#160;<a href="#fnref1%3A6" rev="footnote" class="footnote-backref">&#8617;</a></p>
</li>
<li id="fn:7">
<p><a href="https://de.wikipedia.org/w/index.php?title=Cascading_Style_Sheets&amp;oldid=181828388">https://de.wikipedia.org/w/index.php?title=Cascading_Style_Sheets&amp;oldid=181828388</a> (<a href="https://bit.ly/2BNqmyh">https://bit.ly/2BNqmyh</a>)&#160;<a href="#fnref1%3A7" rev="footnote" class="footnote-backref">&#8617;</a></p>
</li>
<li id="fn:8">
<p><a href="https://de.wikipedia.org/w/index.php?title=Formatvorlage&amp;oldid=183843814">https://de.wikipedia.org/w/index.php?title=Formatvorlage&amp;oldid=183843814</a> (<a href="https://bit.ly/2BKOul8">https://bit.ly/2BKOul8</a>)&#160;<a href="#fnref1%3A8" rev="footnote" class="footnote-backref">&#8617;</a></p>
</li>
<li id="fn:9">
<p><a href="https://wiki.selfhtml.org/index.php?title=JavaScript/DOM&amp;oldid=61063">https://wiki.selfhtml.org/index.php?title=JavaScript/DOM&amp;oldid=61063</a> (<a href="https://bit.ly/2LJJCkQ">https://bit.ly/2LJJCkQ</a>)&#160;<a href="#fnref1%3A9" rev="footnote" class="footnote-backref">&#8617;</a></p>
</li>
<li id="fn:10">
<p><a href="https://www.w3.org/">https://www.w3.org/</a>&#160;<a href="#fnref1%3A10" rev="footnote" class="footnote-backref">&#8617;</a></p>
</li>
<li id="fn:11">
<p><a href="https://whatwg.org">https://whatwg.org</a>&#160;<a href="#fnref1%3A11" rev="footnote" class="footnote-backref">&#8617;</a></p>
</li>
<li id="fn:12">
<p><a href="https://de.wikipedia.org/w/index.php?title=HTML5&amp;oldid=182888530">https://de.wikipedia.org/w/index.php?title=HTML5&amp;oldid=182888530</a> (<a href="https://bit.ly/2RszPoi">https://bit.ly/2RszPoi</a>)&#160;<a href="#fnref1%3A12" rev="footnote" class="footnote-backref">&#8617;</a></p>
</li>
<li id="fn:13">
<p><a href="https://de.wikipedia.org/w/index.php?title=JavaScript_Object_Notation&amp;oldid=183718070">https://de.wikipedia.org/w/index.php?title=JavaScript_Object_Notation&amp;oldid=183718070</a> (<a href="https://bit.ly/2Tc84hc">https://bit.ly/2Tc84hc</a>)&#160;<a href="#fnref1%3A13" rev="footnote" class="footnote-backref">&#8617;</a></p>
</li>
<li id="fn:14">
<p><a href="https://de.wikipedia.org/w/index.php?title=JavaScript_Object_Notation&amp;oldid=183718070">https://de.wikipedia.org/w/index.php?title=JavaScript_Object_Notation&amp;oldid=183718070</a> (<a href="https://bit.ly/2Tc84hc">https://bit.ly/2Tc84hc</a>)&#160;<a href="#fnref1%3A14" rev="footnote" class="footnote-backref">&#8617;</a></p>
</li>
</ol>
</div><h1 id="ecmascript-6-gultigkeitsbereiche-von-variablen">ECMAScript 6 - Gültigkeitsbereiche von Variablen</h1>
<p><a href="#" id="GueltigkeitsbereicheVonVariablen"></a></p>
<p><a href="https://de.wikipedia.org/w/index.php?title=JavaScript&amp;oldid=184218223#Versionsgeschichte_von_ECMAScript_(ECMA-262">https://de.wikipedia.org/w/index.php?title=JavaScript&amp;oldid=184218223#Versionsgeschichte_von_ECMAScript_(ECMA-262</a>)  </p>
<h2 id="diesem-kapitel-werden-wir">In diesem Kapitel werden wir …</h2>
<p>Zunächst zeige ich Ihnen, wie Sie 
Todo Meldungen immer mit Firefox</p>
<h2 id="var-deklaration-und-hoisting">var - Deklaration und Hoisting</h2>
<p><a href="https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Statements/var#var_hoisting">https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Statements/var#var_hoisting</a>
todo was ist deklaration</p>
<p>Die Deklartion einer Variablen erfolgt immer </p>
<ul>
<li>im globalen Kontekt falls die Variable außerhalb einer Funktion deklariert wurde oder </li>
<li>ganz am Anfang einer Funktion.  </li>
</ul>
<p>Konkret bedeutet das, dass das Deklarieren einer Variable irgendwo im Programmcode 
das gleiche ist, als würde sie am Anfang deklariert werden. Eine Variable 
kann somit genutzt werden, bevor sie im Programmcode deklariert wurde. 
Dies nennt man <code>hoisting</code>.  </p>
<blockquote>
<p>Exkurs: Der Unterschied zwischen instanziieren, deklarieren und initialisieren<br />
Variable instanzieren:<br />
Der Begriff Instanziierung meint das Erzeugen eines neuen Objekts, 
also einer Instanz, aus einer Klasse.</p>
<pre><code>Objekt value = new Objekt();
// value ist Instanz der Klasse Objekt</code></pre>
<p>Variable deklarieren:<br />
Unter deklarieren einer Variable können Sie sich das erste <em>Erwähnen der Variable</em> 
vorstellen. So weiß der Compiler, dass es die Variable gibt und kann sie ansprechen. 
Der Wert selbst wird bei der Deklaration nicht festgelegt.</p>
<pre><code>int value;
// value als Variable des Typs int deklariert</code></pre>
<p>Variable initialisieren:<br />
Eine Initialisierung ist das erste Zuweisen eines Wertes zu einer Variablen.</p>
<pre><code>value = 0;
// value mit Wert 0 initialisiert</code></pre>
</blockquote>
<p>Sehen wir uns <code>hoisting</code> an einem Beispiel genauer an.</p>
<h3 id="beispiele">Beispiele</h3>
<h4 id="beispiel-1">Beispiel 1</h4>
<p>Sehen Sie sich die nachfolgende Funktion einmal kurz an. </p>
<pre><code>function getValue() {
    if (false) {
        var value = "Prima";
        return value;
    } else {
        return value; // gibt "undefined" oder "" aus, abhängig vom Browser.
    }
}
&lt;!--index_999a.html--&gt;</code></pre>
<p>Wenn Sie noch nicht vertraut mit JavaScript sind, erwarten Sie vielleicht, dass die 
Variable <code>value</code> nur erstellt wird, wenn die Bedingung in der 
<code>if</code>-Anweisung <code>true</code> ist. In der Realtiät ist es aber so, dass die Variable 
auf alle Fälle erstellt wird.</p>
<p>Im Hintergrund verändert JavaScipt den Programmcode nämlich. Der 
<a href="https://de.wikipedia.org/w/index.php?title=Interpreter&amp;oldid=182588640">Interpreter</a> macht 
daraus konkret den folgenden Aufruf. 
Die wesentliche Zeile habe ich mit einem Stern markiert.</p>
<pre><code> function getValue() {
*    var value;
     if (false) {
         var value = "Prima";
         return value;
     } else {
         return value; // gibt "undefined" oder "" aus, abhängig vom Browser.
     }
     // die Variable value existiert auch hier
 }
&lt;!--index_999a.html aus Sicht des Interpeters--&gt;</code></pre>
<p>Die Deklaration der Variablen <code>value</code> wird an den Anfang der Funktion verschoben. 
Und die Initialisierung erfolgt im gleichen Gültigkeitsbereich. Dadurch kann im 
<code>else</code>-Block auf die Variablen <code>value</code> zugegriffen werden. Da die Variablen <code>value</code> im 
<code>else</code>-Block mit keinem Wert belegt ist, gibt sie bei einem Zugriff <code>undefined</code> 
anstelle von <code>ReferenceError: myvalue is not defined</code> aus. </p>
<pre><code> function getValue() {
     if (false) {
         var value = "Prima";
         return value;
     } else {
*        return myvalue; // gibt "ReferenceError: myvalue is not defined" aus
     }
 }
&lt;!--index_999c.html --&gt;</code></pre>
<p><code>Hoisting</code> führt sehr oft zu Missverständnissen. Für viele Entwickler ist es 
befremdend, dass eine Variable nicht an der Stelle erstellt wird, an der sie im 
Programmcode steht. Wahrscheinlich wurde deshalb mit ECMAScript 6 
die Möglichkeit eingeführt, 
Variablen im Gültigkeitsbereich des lokalen Blocks zu deklarieren.</p>
<p><a href="https://www.mediaevent.de/javascript/globale-lokale-variablen.html">https://www.mediaevent.de/javascript/globale-lokale-variablen.html</a></p>
<h2 id="gultigkeitsbereich-scope-im-block">Gültigkeitsbereich (Scope) im Block</h2>
<p>In vielen Programmiersprachen gibt es den Block Scope – alle Variablen, 
die innerhalb eines Blocks deklariert werden, gelten nur innerhalb dieses Blocks. 
Diese Variablen sind lokale Variablen.</p>
<p>Was genau ist ein Block? Ein Block ist entweder </p>
<ul>
<li>der Bereich innerhalb einer Funktion oder</li>
<li>ein Bereich der mit geschweiften Klammern - <code>{</code> und <code>}</code> - umgeben ist. </li>
</ul>
<p>Variablen, die mit <code>let</code> oder <code>const</code> angelegt werden, gelten nur innerhalb 
ihres Blocks. Das klingt unbequem. Es verhindert aber viele schwer 
aufzudeckende Fehler. </p>
<h3 id="block-scope-mit-let">Block Scope mit let</h3>
<p>Mit ECMAScript 6 ist <code>let</code> für die Deklaration von Variablen hinzugekommen. 
Eine mit <code>let</code> deklarierte Variable hat einen eingeschränkten Gültigkeitsbereich. 
Sie ist nur innerhalb des Blocks, in dem sie deklariert wurden, gültig. </p>
<p>Die Deklaration einer Variablen mit <code>let</code> erfolgt auf die gleiche Art 
wie die Deklaration einer Variablen mit <code>var</code>. Was wäre, wenn die Variable im 
vorherigen Beispiel anstelle von var mit let deklariert worden wäre? Genau dies 
zeigt Ihnend das nachfolgende Beispiel.</p>
<pre><code> function getValue() {
     if (true) {
         let value = "Prima";
     } else {
*        return value; // Würde "ReferenceError: value is not defined" ausgeben.
     }
*    return value; // Gibt "ReferenceError: value is not defined" aus.
}
&lt;!--index_998d.html --&gt;</code></pre>
<p>Haben Sie den Programmcode ausprobiert? Dann stimmen Sie sicher mit mir überein, 
das die Ausgabe der Datei <code>998d.html</code> intuitiver ist als die Ausgabe 
der Datei <code>999a.html</code>. Weil wir die Variable <code>value</code> mit <code>let</code> deklariert haben, 
wird die Deklaration nicht im Hintergrund vom Interpeter an den Anfang der 
Funktion verschoben. Ein Zugriff auf die Variable <code>value</code> ist nun außerhalb 
der <code>if</code>-Anweisung nicht möglich. Da die Variable <code>value</code> nur deklariert wird, 
wenn die Bedingung der <code>if</code>-Anweisung erfüllt ist, kann auch im <code>else</code>-Block 
nicht auf diese zugegriffen werden. Das nächste Beispiel zeigt Ihnen, 
dass die Deklaration der Variable <code>value</code> am Anfang des Blocks in dem diese 
gültig ist erfolgt. Auf die Variable <code>value</code> kann erst nach der Deklaration 
zugegriffen werden. Allerdings ist die Fehlermeldung innerhalb des Blocks, 
indem die Variable deklariert wird, eine andere. </p>
<pre><code>function getValue() {
    if (true) {
        return value; // gibt "ReferenceError: can't access lexical 
                      //declaration `value' before initialization" ausgeben.
        let value = "Prima";
    } else {
        return value; // würde "ReferenceError: value is not defined" ausgeben.
    }
}
&lt;!--index_998e.html --&gt;</code></pre>
<h3 id="keine-mehrfachverwendung">Keine Mehrfachverwendung</h3>
<p>Die Mehrfachverwendung einer mit <code>let</code> deklarierten 
Variablen innerhalb eines Blocks ist nicht möglich. Falls Sie dies versehentlich 
doch tun, wird der JavaScript Interpreter Ihnen den Fehler 
<code>SyntaxError: redeclaration of let value</code> melden.</p>
<pre><code> function getValue() {
     var value = "Prima";
*    let value = "Prima";  // SyntaxError: redeclaration of let value
 }
&lt;!--index_997.html --&gt;</code></pre>
<p>Im vorhergehenden Beispiel wurde die Variable <code>value</code> zweimal deklariert. Einmal 
mit <code>var</code> und einmal mit <code>let</code>. Weil diese beiden Variablen im selben 
Gültigkeitsbereich deklariert wurden, tritt ein Fehler auf. </p>
<p>Im Umkehrschluss ist es möglich, eine Variable mit dem gleichen Namen in einem 
untergeordneten Gültigkeitsbereich zu deklarieren.</p>
<pre><code> function getValue() {
     var value = "Prima";
     if (true) {
*        let value = "Prima";
     return true;
 }
&lt;!--index_997c.html --&gt;</code></pre>
<p>Im Beispiel der Datei <code>997c.html</code> tritt kein Fehler auf. Die Variable <code>value</code> 
wird in der <code>if</code>-Anweisung neu deklariert. Die Deklaration erfolgt genau 
an der Stelle, an der der Programmierer sie in den Programmcode einfügt. 
Die Deklaration wird also nicht wie 
im Falle von <code>var</code>, an den Beginn des umgebenden Blocks gesetzt. </p>
<h3 id="block-scope-mit-const">Block Scope mit const</h3>
<p>Die Deklaration einer Variablen mit <code>const</code> erstellt eine Konstante. 
Der Gültigkeitsbereich einer mit <code>const</code> deklarierten Variablen ist, 
genau wie bei einer mit <code>let</code> deklarierten Variable, auf den lokalen Block begrenzt. 
Der Wert einer Konstanten muss bei der Deklaration initialisiert werden und 
kann später nicht verändert werden.</p>
<pre><code>function getValue() {
    const value1 = "Prima";
    const value2; // SyntaxError: missing = in const declaration
}
&lt;!--index_996.html --&gt;</code></pre>
<p>Im vorherigen Beispiel wird die Variable <code>value1</code> korrekt deklariert und initialisiert. 
Die Deklaration der Variable <code>value2</code> ist nicht möglich. Hier wird ein Fehler 
angezeigt, weil <code>value2</code> beim Anlegen nicht initialisiert wurde.</p>
<h4 id="const-versus-let">const versus let</h4>
<p>Genau wie im Falle von <code>let</code> ist eine mit <code>const</code> deklarierte Variable ausschießlich 
innerhalb eines Blocks gültig. </p>
<pre><code> function getValue() {
     if (true) {
*        const value = "Prima";
     }   
     return value; //ReferenceError: value is not defined
 }
&lt;!--index_995.html --&gt;</code></pre>
<p>Eine weitere Gemeinsamkeit von <code>let</code> und <code>const</code> ist die nicht mögliche 
Mehrfachverwendung.</p>
<pre><code> function getValue() {
     var value1 = "Prima";
     let value2 = "Super";
*    const value1 = "Prima"; // SyntaxError: redeclaration of var value1
*    const value2 = "Super"; // SyntaxError: redeclaration of var value2
     return true;
 }
&lt;!--index_994.html --&gt;</code></pre>
<p>Abgesehen von diesen Gemeinsamkeiten gibt es einen bedeutenden Unterschied. Anders 
als bei einer mit <code>let</code> deklarierten Variablen kann der Wert einer Konstanten 
im Nachhinein nicht geändert werden.</p>
<pre><code> function getValue() {
     let value1 = "Prima";
     const value2 = "Super";
     value1 = "Toll";
*    value2 = "Schön"; // TypeError: invalid assignment to const `value2'
     return true;
 }
&lt;!--index_993.html --&gt;</code></pre>
<h4 id="const-und-objekte">const und Objekte</h4>
<p>Erklärungsbedürftig ist die Behandlung von Konstanten in JavaScript, wenn ein 
Objekt als Konstante deklariert wurde. In diesem Falle ist nur das Objekt 
selbst konstant. Die Eigenschaften des Objektes können verändert werden.</p>
<pre><code>function getValue() {
    const stadt = {
        name: "Koblenz"
    }
    stadt.name = "Bonn"; // Mögliche Neuzuweisung
    stadt.fluss = "Rhein"; // Mögliche Neuzuweisung

    const stadt = { // SyntaxError: redeclaration of const stadt
        name: "Bonn" 
    } 
    return true;
}
&lt;!--index_992.html --&gt;</code></pre>
<h3 id="die-vorubergehend-tote-zone">Die vorübergehend tote Zone</h3>
<p>Variablen, die mit <code>let</code> oder <code>const</code> angelegt werden, gelten nur innerhalb 
ihres Blocks. Dies führt in JavaScript zu einem Zustand der sich gefährlich 
anhört: <em>Der vorübergehend toten Zone</em>. Der englische Ausdruck dafür ist 
<em>Temporal Dead Zone (TDZ)</em>. In der <em>vorübergehend toten Zone</em> tritt beim Zugriff 
auf eine deklarierte Variable, ein Fehler auf. Verhängnisvoll ist, dass 
dieser Fehler auch dann auftritt, wenn eine vermeintlich sichere 
Methode wie <code>typeof</code> verwendet wird.</p>
<pre><code> function getValue() {
     console.log(typeof value1); // Ausgabe: undefined
*    console.log(typeof value2); // ReferenceError: can't access lexical declaration
                                 // `value2' before initialization
     let value2 = "Prima"; 
    return true;
}
&lt;!--index_991.html --&gt;</code></pre>
<p>In vorhergehenden Beispiel wird auf die Variablen <code>value1</code> und 
<code>value2</code> mithilfe von <code>typeof</code> 
zugegriffen. Im Falle von <code>value1</code> ist dies auch kein Problem. Bei <code>value2</code> 
tritt hingegen ein Fehler auf, weil <code>value2</code> im gleichen 
Gültigkeitsbereich später noch einmal mit <code>let</code> deklariert wird.  </p>
<p>Die gleiche Deklaration in einem 
anderen Gültigkeitsbereich 
wäre kein Problem, wie Beispiel <code>index_991c.html</code> zeigt. </p>
<pre><code>function getValue() {
    console.log(typeof value1); // Ausgabe: undefined
    console.log(typeof value2); // Ausgabe: undefined

    if (true) {
        let value2 = "Prima";
    }

    return true;
}
&lt;!--index_991c.html --&gt;</code></pre>
<blockquote>
<p>Die Bezeichnung <em>Temporal Dead Zone (TDZ)</em> sucht man in der Spezifikation 
<em>ECMAScript 6</em> vergeblich. Der Begriff wird aber häufig zur Erklärung eingesetzt. Die 
TDZ entsteht, weil der JavaScript-Interpreter sich einen Block schon beim Einlesen 
vollständig ansieht. Wenn er eine mit <code>var</code> deklarierte Variable findet, dann setzt er die 
Deklaration an den Beginn der Funktion oder in den globalen Gültigkeitsbereich. Findet 
der Interpreter eine mit <code>let</code> oder <code>const</code> deklarierte Variable, dann setzt er diese 
in die TDZ - solange, bis die eigenliche Deklaration erfolgt.</p>
</blockquote>
<pre><code>function getValue() {
     console.log(typeof value); // Ausgabe: undefined
*    if (true) {
*        let value = "Prima";
*        console.log(typeof value); // Ausgabe: String
*    }
     console.log(typeof value); // Ausgabe: undefined
     return true;
 }
&lt;!--index_991a.html --&gt;</code></pre>
<p>Die Variable <code>value2</code> befindet sich nicht in der TDZ wenn der Befehl 
<code>console.log(typeof value)</code> ausgeführt wird. Das bedeutet konkret, dass die Variable 
frei aber tatsächlich <code>undefinded</code> ist.</p>
<blockquote>
<p>Die Beispiele zur TDZ verwenden hier mithilfe von <code>let</code> deklarierte Variablen. Das 
Gleiche gilt aber auch für Variablen, die mit <code>const</code> deklariert wurden.</p>
</blockquote>
<h2 id="gultigkeitsbereich-scope-schleifen">Gültigkeitsbereich (Scope) in Schleifen</h2>
<p>Eine weitere Besonderheit von JavaScript ist der Gültigkeitsbereich innerhalb von 
Schleifen. Beim Druchlaufen 
von Schleifen bringt es viele Vorteile wenn die Gültikeitesbereiche der Variablen 
übersichtlich und getrennt sind. In einer Schleife wird häufig eine Variable als Zähler 
verwendet. Das nächste Beispiel zeigt Ihnen, dass der Gültigkeitsbereich einer 
solchen Zählervariablen nicht übersichtlich und getrennt ist, wenn diese Variable 
mit <code>var</code> deklariert wird. </p>
<pre><code> function getValue() {
     for (var i = 0; i &lt; 5; i++) {
         // tue etwas ...
     }
*    console.log(i); // Ausgabe: 5
     return true;
 }
&lt;!--index_990.html --&gt;</code></pre>
<p>Auch nachdem der Schleifendurchlauf abgeschlossen ist und der Block verlassen wurde, 
ist die Variable <code>i</code> noch gültig. Der letzte Wert der Variablen wird mittels 
<code>console.log(i)</code> ausgegeben. Dies ist ein Verhalten, das nicht erwünscht ist. Die 
Variable <code>i</code> wird in der Regel nur lokal in der Schleife benötigt und sollte auch 
nur hier ihren Gültigkeitsbereich haben. Bei der Verwendung von <code>var</code> zur Deklaration 
wird diese Deklaration aufgrund von 
<a href="https://de.wikipedia.org/w/index.php?title=Hoisting&amp;oldid=166784898">Hoisting</a> 
an den Anfang der Funktion geschoben und ist somit innerhalb der vollständigen 
Funktion gültig.</p>
<p>Das nächste Beispiel nutzt anstelle von <code>var</code> eine mit <code>let</code> deklarierte Variabel als 
Zähler. Das Ergebnis ist das erwartete Verhalten.</p>
<pre><code> function getValue() {
     for (let i = 0; i &lt; 5; i++) {
         console.log(i); // Ausgabe: 0 1 2 3 4
     }
*    console.log(i); // ReferenceError: i is not defined
     return true;
 }
&lt;!--index_989.html --&gt;</code></pre>
<p>Das Beispiel der Datei <code>index_989.html</code> demonstriert das gewünschte Verhalten. Die 
Variable <code>i</code> existiert nur innerhalb der Schleife. Nachdem die Schleife abgearbeitet 
ist, kann auf die Variable <code>i</code> nicht mehr zugegriffen werden. Die Variable <code>i</code> kann<br />
keine Verwirrung mehr stiften.</p>
<h3 id="funktionen-schleifen">Funktionen in Schleifen</h3>
<p>Hoisting und das Verhalten von <code>var</code> machen das Arbeiten mit Funktionen in Schleifen 
unvorhersehbar. Das nächste Beispiel zeigt Ihnen, auf was ich genau hinaus will.</p>
<pre><code>function getValue() {
    var funktionen = [];
    for (var i = 0; i &lt; 5; i++) {
        funktionen.push(function() {
            console.log(i);
        });
    }
    funktionen.forEach(function(funktion){
        funktion(); // Ausgabe: Fünfmal die Nummer "5"
    });
    return true;
}
&lt;!--index_988.html --&gt;</code></pre>
<p>Haben Sie die Ausgabe <code>0 1 2 3 4</code> erwartet? Anstelle davon wurde aber
<code>5 5 5 5 5</code> ausgegeben. Der Grund hierfür ist, dass dieselbe Variable <code>i</code> über alle 
Iterationen der Schleife hinweg geteilt wird. Aufgrund von Hoisting wurde 
die Variable <code>i</code> außerhalb der Schleife deklariert. Alle Funktionen, die in der 
Schleife erstellt wurden, halten eine Referenz auf die selbe Variable <code>i</code>. 
Diese Variable <code>i</code> hat den Wert <code>5</code>, wenn alle Schleifendurchläufe beendet sind. 
Wenn dann <code>console.log(i)</code> aufgrund von </p>
<pre><code>funktionen.forEach(function(funktion){
    funktion(); 
});</code></pre>
<p>fünfmal ausgeführt wird, wird der Wert <code>5</code> fünfmal ausgegeben.  </p>
<p>Eine Lösung für dieses Problem ist 
<a href="https://wiki.selfhtml.org/index.php?title=IIFE&amp;oldid=59916">IIFE</a>. 
<em>IIFE</em> steht für <em>Immediately-invoked Function Expression</em>, 
also ein sofort ausgeführter Funktionsausdruck. Das hört sich sehr kompliziert 
an. Meiner Meinung nach 
ist es auch kompliziert. Ich habe <em>IIFE</em> hier der Vollständigkeit halber 
aufgenommen. 
Im nächsten Kapitel finden Sie eine einfachere Lösung - seit ECMAScript 6.  </p>
<pre><code>function getValue() {
    var funktionen = [];
    for (var i = 0; i &lt; 5; i++) {
        funktionen.push((function(value) {
            return function (){
                console.log(value);
            }
        }(i)));
    }
    funktionen.forEach(function(funktion){
        funktion(); // Ausgabe: 0 1 2 3 4 
    });
    return true;
}
&lt;!--index_987.html --&gt;</code></pre>
<p>Das Beispiel der Datei <code>index_987.html</code> verwendet eine IIFE. Das Grundgerüst 
einer IIFE finden Sie im nächsten Programmcodebeispiel.</p>
<pre><code>(function (foo) {
    //...
})(foo);</code></pre>
<p>Dieses Grundgerüst sieht noch recht einfach aus. Beispiel <code>index_987.html</code> wirkt hingegen 
recht kompliziert. Deshalb sehen wir uns die relevanten Teile genauer an. 
Die Variable <code>i</code> wird im Beispiel <code>index_987.html</code> an die IIFE übergeben. Im 
nachfolgenden Programmcodebeispiel habe ich die IIFE des Beispiel <code>index_987.html</code> 
für sich alleine eingefügt.</p>
<pre><code>...
...(function(value) {
       return function (){
           console.log(value);
       }
   }(i))...
...</code></pre>
<p>Die IIFE speichert die 
Variable <code>i</code> in einer eigenen Kopie. In unserem Beispiel erhält diese Kopie 
den Namen <code>value</code>. Die Kopie der Variablen <code>i</code>, also <code>value</code> wird nun in der 
Funktion verwendet. Dies führt dazu, dass die Ausgabe der Schleife nun eher der 
Erwartung eines Programmierers entspricht, als die Ausgabe der Schleife in Beispiel 
<code>index_988.html</code>. 
Wie schon erwähnt bietet ECMAScript 6 glücklicherweise eine einfacherer Möglichkeit, 
diese Ausgabe zu erreichen. Und  diese Möglichkeit sehen wir uns im nächsten Kapitel an.</p>
<h3 id="let-schleifen">let in Schleifen</h3>
<p>Eine mit let deklarierte Variable <code>i</code> in der Schleifenbedingung vereinfacht 
die arbeit mit der Schleife ungemein. 
Bei jedem Schleifendurchlauf wird aufgrund von <code>let</code> eine neue Variable <code>i</code> 
erstellt und mit dem aktuellen 
Wert initialisiert. Das nächste Beispiel zeigt Ihnen, dass man so vollständig 
auf das komplizierte 
IIFE Konstrukt verzichten kann.</p>
<pre><code>function getValue() {
    var funktionen = [];
    for (let i = 0; i &lt; 5; i++) {
        funktionen.push(function() {
            console.log(i);
        });
    }
    funktionen.forEach(function(funktion){
        funktion(); // Ausgabe: 0 1 2 3 4
    });
    return true;
}
window.addEventListener("load", function () {
console.log(getValue());
});
&lt;!--index_986.html --&gt;</code></pre>
<p>Das Beispiel der Datei <code>index_986.html</code> errechnet genau das, was das Beispiel 
der Datei <code>index_987.html</code> errechnete - allerdings auf eine wesentlich 
komfortable Art.</p>
<p>todo for in und for of erklären?</p>
<p>Mit dem Beispiel der Datei <code>index_985.html</code> können Sie sich davon überzeugen, dass das 
was ich gerade für eine forEach Schleife beschrieben habe, auch auf <code>for-in</code> und <code>for-of</code> 
Schleifen zutrifft.  </p>
<p><code>for-of</code>:</p>
<pre><code>function getValue() {
    var funktionen = [];
    var names = ['Astrid', 'Nina', 'Elmar'];

    for (let name of names) {
        funktionen.push(function() {
            console.log(name);
        });
    }
    funktionen.forEach(function(funktion){
        funktion(); 
    });
    return true;
}
&lt;!--index_985.html --&gt;</code></pre>
<p><code>for-in</code>:</p>
<pre><code>function getValue() {
    var funktionen = [];
    var object = {
        1 : "a",
        2 : "b",
        3 : "c"
    };

    for (let key in object) {
        funktionen.push(function() {
            console.log(key);
        });
    }
    funktionen.forEach(function(funktion){
        funktion(); 
    });
    return true;
}
&lt;!--index_984.html --&gt;</code></pre>
<p>In den Beispielen zur <code>for-in</code>-Schleife und zur <code>for-of</code>-Schleife wird bei jedem 
Schleifendurchlauf eine Kopie von <code>key</code> angelegt. Dies geschieht, weil <code>key</code> 
mit <code>let</code> deklariert wurde. Für die Ausgabe wird immre diese Kopier verwendet. 
Deshalb ist die Ausgabe im ersten Fall <code>Astrid Nina Elmar</code> und im zweiten Fall 
<code>1 2 3</code>. 
Wenn <code>key</code> mit <code>var</code> deklariert würde, würde im ersten 
Fall dreimal <code>Elmar</code> ausgegeben und im zweiten Fall dreimal <code>3</code>.</p>
<h3 id="const-schleifen">const in Schleifen</h3>
<p>Die ECMAScript 6 Spezifikation verbietet die Verwendung von Konstanten als 
Schleifenbedingung nicht. Wer eine Konstante als Schleifenbedingung verwenden 
möchte, sollte sich die Zusammenhänge genau ansehen. Die <code>for-in</code>-Schleife und 
die <code>for-of</code>-Schleife nutzen eine Konstante anders, als eine normale 
<code>for</code>-Schleife es tut.</p>
<h4 id="schleife">For-Schleife</h4>
<p>In einer einfache For-Schleife ist es zwar erlaubt die Schleifenbedingung als 
Konstante zu initialisieren. Es ist aber in den meisten Fällen nicht sinnvoll. 
Bei der Ausführung der Schleife wird nämlich ein Fehler gemeldet, wenn 
der Wert der Konstanten geändert werden soll.</p>
<pre><code>function getValue() {
    var funktionen = [];
    for (const i = 0; i &lt; 5; i++) {
        funktionen.push(function() {
            console.log(i);
        });
    }
    funktionen.forEach(function(funktion){
        funktion(); // Ausgabe: TypeError: invalid assignment to const i
    });
    return true;
}
&lt;!--index_983.html --&gt;</code></pre>
<p>Im vorhergehen Beispiel wird die Variable <code>i</code> als Konstante deklariert. Der erste 
Schleifendurchlauf ist erfolgreich. Bei diesem Schleifendurchlauf ist der Wert 
der Variablen <code>i</code> gleich <code>0</code>. Beim nächsten Schleifendurchlauf tritt dann allerdings 
ein Fehler auf. Dieser Fehler tritt genau auf, wenn <code>i++</code> ausgeführt werden soll.
Die Fehlermeldung lautet im Browser Firefox <code>TypeError: invalid assignment to const i</code>.  </p>
<p>Das nächste Programmcodebeispiel zeigt ein etwas konstruiertes Beispiel. 
Im Beispiel wird 
in der Schleifenbedingung eine Konstante verwendet. Es tritt aber kein Fehler auf, 
weil die Schleife mit <code>break</code> abbricht, bevor <code>i++</code> ausgeführt wird.</p>
<pre><code>function getValue() {
    var funktionen = [];
    for (const i = 0; i &lt; 5;) {
        funktionen.push(function() {
            console.log(i);
        });
        break;
    }
    funktionen.forEach(function(funktion){
        funktion(); // Ausgabe: 0
    });
    return true;
}
&lt;!--index_983c.html --&gt;</code></pre>
<h4 id="schleife-und-schleife">For-in-Schleife und For-of-Schleife</h4>
<p>In einer <code>for-in</code>-Schleife oder einer <code>for-of</code>-Schleife kann hingegen mit einer 
Konstanten gearbeitet werden. </p>
<pre><code>function getValue() {
    var funktionen = [];
    var names = ['Astrid', 'Nina', 'Elmar'];

    for (const name of names) {
        funktionen.push(function() {
            console.log(name);
        });
    }
    funktionen.forEach(function(funktion){
        funktion(); // Ausgabe: Astrid Nina Elmar
    });
    return true;
}
&lt;!--index_983a.html --&gt;</code></pre>
<pre><code>function getValue() {
    var funktionen = [];
    var object = {
        1 : "a",
        2 : "b",
        3 : "c"
    };

    for (const key in object) {
        funktionen.push(function() {
            console.log(key);
        });
    }
    funktionen.forEach(function(funktion){
        funktion(); // Ausgabe: 1 2 3
    });
    return true;
}
&lt;!--index_983b.html --&gt;</code></pre>
<p>Der warum in einer <code>for-in</code>-Schleife oder einer <code>for-of</code>-Schleife eine Konstante 
als Schleifenbedingung keinen Fehler erzeugt ist bei genauem Hinsehen einfach. Beim 
Schleifendurchlauf wird keiner Konstanten ein anderer Wert zugeordnet. Es wird 
vielmehr die Zuordnung zu zur Konstanten <code>name</code> oder <code>key</code> geändert.</p>
<h2 id="globaler-gultigkeitsbereich-scope">Globaler Gültigkeitsbereich (Scope)</h2>
<p>Auch im globalen Gültigkeitsbereich gibt es Unterschiede zwischen <code>var</code> und 
den ECMAScript 6- Neulingen <code>let</code> beziehungsweise <code>const</code>.  </p>
<p>Zum einen überschreibt eine im globalen Gültigkeitsbereich mit <code>var</code> 
deklarierte Variable die gleichnamige Eigenschaft im <code>window</code> Objekt. 
Das nachfolgende Beispiel verdeutlich das gerade beschriebene. So hat 
JavaScript in der Vergangenheit immer gearbeitet.</p>
<pre><code>console.log(window.RegExp); // Ausgabe: function RegExp()
var RegExp = "Neuer Wert für RegExp";
console.log(window.RegExp); // Ausgabe: "Neuer Wert für RegExp"
&lt;!--index_982.html --&gt;</code></pre>
<p>Wenn anstelle von <code>var</code> eine Variable im globalen Gültikeitsbereich mit <code>let</code> 
beziehungsweise <code>const</code> deklariert wird wird das <code>window</code> Objekt nicht verändert.</p>
<pre><code>console.log(window.RegExp); // Ausgabe: function RegExp()
let RegExp = "Neuer Wert für RegExp";
console.log(window.RegExp); // Ausgabe: function RegExp()
&lt;!--index_981.html --&gt;</code></pre>
<p>Dadurch, dass das globale <code>window</code>-Objekt im Falle von <code>let</code> 
beziehungsweise <code>const</code>nicht geändert wird, ist die Variablenzuweisunge 
sicherer. Das unbewusste überschreiben von Eigenschaften im <code>window</code>-Objekt kann 
nicht vorkommen.</p>
<blockquote>
<p>Die Verwendung von <code>var</code> kann zur Deklaration einer 
globalen Variablen dennnoch sinnvoll sein. Auf diese Art und Weise können Variablen 
von unterschiedlichen HTML-Dokumenten gleichzeitig genutzt werden.</p>
</blockquote>
<h2 id="erfolgsmethode-best-practice">Erfolgsmethode - best practice</h2>
<blockquote>
<p><strong>Achtung:</strong></p>
</blockquote>
<h2 id="diesem-kapitel-haben-wir">In diesem Kapitel haben wir ...</h2>
<p>xxx</p>
<div class="footnotes">
<hr />
<ol>
</ol>
</div><h1 id="ecmascript-6-arbeiten-mit-strings">ECMAScript 6 - Arbeiten mit Strings</h1>
<p><a href="#" id="ArbeitenMitStrings"></a></p>
<h2 id="diesem-kapitel-werden-wir">In diesem Kapitel werden wir …</h2>
<p>Zunächst zeige ich Ihnen, wie Sie 
Todo Meldungen immer mit Firefox</p>
<h2 id="verbesserte-unicode-unterstutzung">Verbesserte Unicode-Unterstützung</h2>
<h3 id="utf-16">UTF-16</h3>
<p>ECMAScript 5 entstand, als 16 Bit ausreichten, um alle vorhandene Unicode-Zeichen 
abzubilden. Später wurde Unicode um weitere Zeichen mit einem erweitert. 
Dies hat zur Folge, 
dass 16 Bit nicht mehr ausreichen, um alle möglichen Unicode-Zeichen darzustellen.</p>
<blockquote>
<p>Das Ziel von Unicode ist es, alle in Gebrauch befindlichen Schriftsysteme 
und Zeichen zu kodieren. Der Zeichenumfang ist dazu 
in 17 Ebenen (englisch planes) gegliedert. 
Sechs dieser Ebenen werden bereits verwendet, die restlichen sind für spätere Nutzung reserviert. 
Die ursprünglichen 16 Bit sind unter dem Namen <em>Basic Multilingual Plane</em> 
(BMP; deutsch Mehrsprachige Basis-Ebene, auch als Plane 0 bezeichnet) bekannt.</p>
</blockquote>
<p>Damit die ursprünglichen 16 Bit auch weiterhin problemlos 
verwendet werden könne, speichert UTF-16 die ursprünglichen Unicode-Zeichen in der BMP 
weiterhin in 16 Bit. 
Alle neuen Unicode-Zeichen werden hingegen in 32 Bit 
gespeichert, also in zwei 16-Bit-Werten. 
Diese beiden 16-Bit-Werte werden als <em>Ersatzpaar</em> (englisch surrogate pair) bezeichnet. 
Streng genommen wird ein Unicode-Zeichen außerhalb der BMP in einer 
<em>UTF-16-Codeeinheit</em> anstelle eines <em>Unicode-Zeichens</em> gespeichert.</p>
<p>So können Sie alle Methoden die auf 16 Bit begrenzt sind weiterhin 
nutzen. Zumindest solange die Zeichen der BMP ausreichen - das heißt solange 
Sie keine der neuen Unicode-Zeichen verwenden.</p>
<p>Wenn Sie eine vollständige Unicode-Unterstützung benötigen, kann die Verwendung 
der alten Methoden zu versteckten Fehlern führen.</p>
<blockquote>
<p>Ein sehr populäres Beispiel für Unicode-Zeichen, die nicht im BMP 
enthalten sind sind Emojis: Das einfache lachende Gesicht 😀 
<a href="https://unicode-table.com/de/#1F600">U + 1F600</a>
kann nicht in einem einzelnen Zeichen dargestellt werden.</p>
</blockquote>
<p>Was ich genau mit versteckten Fehler meine, verdeutlicht der nachfolgende 
Programmcode. Als Beispiel habe ich das Leerzeichen und das Emoji mit dem 
lachenden Gesicht gegenübergestellt. 
Die Unicode-Nummer des Emoji mit dem 
lachenden Gesicht ist <code>U+1F600</code> und der HTML-Code dazu 
ist <code>&amp;#128512;</code>. 
Die Unicode-Nummer das Ausrufezeichen ist <code>U+0021</code> und der HTML-Code dazu 
ist <code>&amp;#33;</code>.</p>
<pre><code>let text = "😀";
console.log(text.length); // Ausgabe: 2
console.log(/^.$/.test(text)); // Ausgabe: false
console.log(text.charAt(0)); // Ausgabe: �
console.log(text.charAt(1)); // Ausgabe: �
console.log(text.charCodeAt(0)); // Ausgabe: 55357
console.log(text.charCodeAt(1)); // Ausgabe: 56832

text = "!";
console.log(text.length); // Ausgabe: 1
console.log(/^.$/.test(text)); // Ausgabe: true
console.log(text.charAt(0)); // Ausgabe: "!"
console.log(text.charAt(1)); // Ausgabe: ""
console.log(text.charCodeAt(0)); // Ausgabe: 33
console.log(text.charCodeAt(1)); // Ausgabe: NaN
&lt;!--index_980.html --&gt;</code></pre>
<p>Es wird kein Fehler angezeigt, aber anders als erwartet  </p>
<ul>
<li>gibt <code>text.length</code> für das lachende Gesicht den Wert 2 anstelle von 1 zurück.</li>
<li>wird das lachende Gesicht beim der Prüfung eines Regulären Ausdrucks nicht 
als ein Zeichen erkannt.</li>
<li>es der <code>charAt()</code>-Methode nicht möglich ein Zeichen zurückzugeben.</li>
<li>gibt die <code>charCodeAt()</code>-Methode für jedes der beiden Zeichen in der UTF-16-Codeeinheit 
das Unicode-Zeichen für die BMP aus. </li>
</ul>
<p>Falls Sie mit Unicode-Zeichen oberhalb der BMP arbeiten sind die Methoden 
<code>charAt()</code> und <code>charCodeAt()</code> nicht die richtige Wahl für Sie. Diese arbeiten 
ausschließlich im BMP-Bereich korrekt. Und noch schlimmer: Bei Unicode-Zeichen 
außerhalb der BMP melden diese keinen Fehler.  </p>
<p>Mit ECMAScript 6 sind 
Methoden hinzugekommen, die den neuen Bereich korrekt unterstützen. </p>
<blockquote>
<p>Die Unicode-Nummer ist ein hexadezimaler Wert. Der HTML-Code ist die 
ins Dezimalsystem umgerechnete Unicode-Nummer.
Möchten Sie das Umrechnen von einem Zahlenformat in ein anderes Zahlenformat 
gerne selbst 
nachvollziehen. Falls Sie hierzu Hilfe benötigen ist die Website<br />
<a href="https://www.arndt-bruenner.de/mathe/scripts/Zahlensysteme.htm">https://www.arndt-bruenner.de/mathe/scripts/Zahlensysteme.htm</a> vielleicht das 
Richtige für Sie.</p>
</blockquote>
<h3 id="codepointat">codePointAt()</h3>
<p>Eine Methode, eine vollständige Unicode-Unterstützung bietet ist <code>codePointAt()</code></p>
<pre><code>let text = "😀";
console.log(text.codePointAt(0)); // Ausgabe: 128512
console.log(text.codePointAt(1)); // Ausgabe: 56832

text = "!";
console.log(text.codePointAt(0)); // Ausgabe: 33
console.log(text.codePointAt(1)); // Ausgabe: undefined
&lt;!--index_979.html --&gt;</code></pre>
<p>Noch einmal zur Wiederholung: Die Unicode-Nummer des Emoji mit dem 
lachenden Gesicht ist <code>U+1F600</code> und der HTML-Code dazu 
ist <code>&amp;#128512;</code>. 
Die Unicode-Nummer das Ausrufezeichen ist <code>U+0021</code> und der HTML-Code dazu 
ist <code>&amp;#33;</code>. <code>codePointAt(0)</code> gibt nun also in beiden Fällen denn korrekten Wert 
zurück.</p>
<blockquote>
<p>Bei der verwendung der <code>codePointAt()</code>-Method ist allerdings noch wichtig 
darauf zu achten, das auch hier die UTF-16-Codeeinheit zürckgegeben wird - also 
zwei Unicode-Zeichen. Sehen sich zur verdeutlichung nachfolgenden Programmcode an.</p>
</blockquote>
<pre><code>let text = "😀!";
console.log(text.codePointAt(0)); // Ausgabe: 128512
console.log(text.codePointAt(1)); // Ausgabe: 56832
console.log(text.codePointAt(2)); // Ausgabe: 33
console.log(text.codePointAt(1)); // Ausgabe: undefined
&lt;!--index_979a.html --&gt;</code></pre>
<blockquote>
<p>Wenn Sie herausfinden möchten, ob Sie es mit einem Unicode-Zeichen oder einer 
UTF-16-Codeeinheit zu tun haben, können Sie die Methode <code>codePointAt(0)</code> zu Hilfe 
nehmen. Eine Möglichkeit zeigt Ihnen das nächste Codebeispiel.</p>
<pre><code>console.log(is32Bit("😅")); // Ausgabe: true
console.log(is32Bit("!"));  // Ausgabe: false
function is32Bit(c){
return c.codePointAt(0) &gt; 0xFFFF;
}
&lt;!--index_978.html --&gt;</code></pre>
</blockquote>
<h3 id="stringfromcodepoint">String.fromCodePoint()</h3>
<p>Im vorhergehenden Kapitel haben wir HTML-Code eines Zeichens ermittelt. In 
diesem Kapitel machen wir das Gegenteil. Bisher war für die Errechnung eines 
Zeichens aus einem HTML-Code die Methode 
<code>fromCharCode()</code> das Mittel der Wahl. Genau wie <code>charCodeAt()</code> deckt <code>fromCharCode()</code> 
außschließlich den BMP-Bereich korrekt ab. Analog zu <code>codePointAt()</code> 
für <code>charCodeAt()</code> gibt es die fromCodePoint()-Methode als Pentant zu 
<code>fromCharCode()</code>. <code>fromCodePoint()</code> bietet das gleiche Ergebnis 
wie <code>fromCharCode()</code> bei einer vollständige Unicode-Unterstützung.</p>
<table>
<thead>
<tr>
<th>BMP-Bereich</th>
<th>vollständige Unicode-Unterstützung</th>
</tr>
</thead>
<tbody>
<tr>
<td>fromCharCode()</td>
<td>fromCodePoint()</td>
</tr>
<tr>
<td>charCodeAt()</td>
<td>codePointAt()</td>
</tr>
</tbody>
</table>
<h3 id="normalize">normalize()</h3>
<p>Ein interessanter Aspekt beim Vergleichen oder beim Sortieren von Strings sind 
die unterschiedlichen Möglichkeiten, mit denen das gleiche Zeichen dargestellt 
werden kann. 
Beispielsweise kann der Buchstabe <code>Ä</code> als einzelnes Unicode-Zeichen 
<code>U + 00E4 LATIN SMALL LETIN A MIT DIAERESIS</code> oder als zwei Unicode-Zeichen 
<code>U + 0061 LATIN SMALL LETIN A</code> and <code>U + 0308 COMBINING DIAERESIS</code> dargestellt werden. 
Meistens wird die erste Form verwendet. 
Wenn sie zwei Strings vergleiche, die den Buchstaben <code>Ä</code> auf unterschiedliche Art 
speichern, dann kann dies beim Sortieren oder beim Vergleichen unerwarteten Ergebnissen 
führen.</p>
<blockquote>
<p>Es gibt vier Normalformen: </p>
<ul>
<li>die kanonische Dekomposition (NFD), </li>
<li>die kanonische Dekomposition gefolgt von einer kanonischen Komposition (NFC), </li>
<li>die kompatible Dekomposition (NFKD) und </li>
<li>die kompatible Dekomposition gefolgt von einer kanonischen Komposition (NFKC).  </li>
</ul>
</blockquote>
<p>In JavaScript ist ein String standardmäßig in der Normalform NFC.</p>
<blockquote>
<p>Eine genaue Erklärung dieser Formen führt 
hier zu weit. Einen guten Einstieg zum Thema bietet Ihnen Wikpedia: 
<a href="https://de.wikipedia.org/w/index.php?title=Normalisierung_(Unicode)&amp;oldid=178027174">https://de.wikipedia.org/w/index.php?title=Normalisierung_(Unicode)&amp;oldid=178027174</a> . 
Was Sie sich auf jeden Fall merken sollten: Beim Vergleichen - beziehungsweise beim 
Sortieren - müssen beide zu vergleichenden Strings in der gleichen Normalform vorliegen. 
Andernfalls kann es Probleme geben.</p>
</blockquote>
<p>Wie erreichen Sie, dass ein String in eine bestimmte Normalform überführt wird? 
Seit ECMAScript 6 können Sie hierfür die Methode <code>normalize()</code> verwenden. Im nächsten 
Beispiel sehen Sie beispielhaft, wie Sie die Methode <code>normalize()</code> praktisch einsetzen 
können. </p>
<pre><code>let eins = "Äpfel";
let zwei = "Äpfel";

let einsNFD = eins.normalize("NFD");
let zweiNFD = zwei.normalize("NFD");

let einsNFC = eins.normalize("NFC");
let zweiNFC = zwei.normalize("NFC");

console.log(eins===zwei); //true
console.log(eins===einsNFD); //false
console.log(eins===einsNFC); //true

console.log(eins===zweiNFD); //false
console.log(eins===zweiNFC); //true
&lt;!--index_977.html --&gt;</code></pre>
<p>Das Programmcodebeispiel spricht für sich. Falls der String <code>Äpfel</code> in unterschiedlichen<br />
Normalformen vorliegt, schlägt eine Prüfung auf Gleichheit fehl.</p>
<p>Falls Sie bisher noch nie auf ein Problem mit unterschiedlichen Unicode Normalformen 
gestoßen sind, dann ist es nicht wahrscheinlich, dass Sie diese Methode benötigen. Es 
schade jedoch nie diese Methode für den Fall der Fälle im Hinterkopf zu behalten.</p>
<h3 id="u-flag">u-Flag</h3>
<h4 id="das-u-flag-aktion">Das u-Flag in Aktion</h4>
<p>Im Beispiel 980.html hatte ich gezeigt, dass eine Prüfung eines regulären Ausdrucks 
auf die Länge ein unerwartetes Ergebnis bringt, wenn das Zeichen im regulären Ausdruck 
sich nicht im BMP Bereich befindet. 
Ein Unicode-Zeichen außerhalb der BMP wird wie schon beschrieben in einer 
<em>UTF-16-Codeeinheit</em> anstelle eines <em>Unicode-Zeichens</em> gespeichert. </p>
<p>ECMAScript 6 schafft hier mit dem u-Flag abhilfe. Wenn dieses Flag gesetzt ist, 
wird der reguläre Ausdruck nicht anhand von <em>UTF-16-Codeeinheit</em> interpretiert</p>
<pre><code>let text = "😀";
console.log(text.length); // Ausgabe: 2
console.log(/^.$/.test(text)); // Ausgabe: false
console.log(/^.$/u.test(text)); // Ausgabe: false

text = "!";
console.log(text.length); // Ausgabe: 1
console.log(/^.$/.test(text)); // Ausgabe: true
console.log(/^.$/u.test(text)); // Ausgabe: false
&lt;!--index_976.html --&gt;</code></pre>
<h4 id="codepoints-zahlen">Codepoints zählen</h4>
<pre><code>function codePointLengthWithU(text){
    let sum = text.match(/[\s\S]/gu);
    return sum ? sum.length : 0;
} 
function codePointLengthWithoutU(text){
    let sum = text.match(/[\s\S]/g);
    return sum ? sum.length : 0;
} 
let text = "😀";
console.log(text.length); // Ausgabe: 2
console.log(codePointLengthWithU(text)); // Ausgabe: 1
console.log(codePointLengthWithoutU(text)); // Ausgabe: 2

text = "!";
console.log(text.length); // Ausgabe: 1
console.log(codePointLengthWithU(text)); // Ausgabe: 1
console.log(codePointLengthWithoutU(text)); // Ausgabe: 1
&lt;!--index_975.html --&gt;</code></pre>
<h4 id="browserunterstuztung-des-u-flags">Browserunterstüztung des u-Flags</h4>
<pre><code>function hasUFlag(){
    try {
        let pattern = new RegExp(".", "u");
        return true;
    } catch (ex) {
        return false;
    }
} 
console.log(hasUFlag()); // Ausgabe true wenn das u-Flag vom Browser unterstüzt wird
&lt;!--index_974.html --&gt;</code></pre>
<h2 id="andere-verbesserungen-im-zusammenhang-mit-zeichenketten">Andere Verbesserungen im Zusammenhang mit Zeichenketten</h2>
<p>Das Suchen von Zeichenketten innerhalb von Zeichenketten war bisher recht 
aufwendig. </p>
<h3 id="identifizieren">Identifizieren</h3>
<h4 id="zeichenketten-zeichenketten">Zeichenketten in Zeichenketten</h4>
<p>Um eine Zeichenkette innerhalb einer Zeichenkette zu finden, war bisher der Weg 
über die <code>indexOf()</code>-Methode das Mittel der Wahl. Mit ECMAScript 6 gibt es nun 
zusätzlich die Methoden </p>
<ul>
<li><code>startsWith()</code></li>
<li><code>endsWith()</code></li>
<li><code>includes()</code></li>
</ul>
<pre><code>let meinString = "ECMAScript 6 mit Beispielen lernen";

console.log(meinString.startsWith("E")); // Ausgabe true
console.log(meinString.endsWith("n")); // Ausgabe true
console.log(meinString.includes("i")); // Ausgabe true

console.log(meinString.startsWith("i")); // Ausgabe false
console.log(meinString.endsWith("lernen")); // Ausgabe true
console.log(meinString.includes("ä")); // Ausgabe false

console.log(meinString.startsWith("i", 7)); // Ausgabe true
console.log(meinString.endsWith("r", 7)); // Ausgabe true
console.log(meinString.includes("i", 22)); // Ausgabe true
console.log(meinString.includes("i", 23)); // Ausgabe false
&lt;!--index_973.html --&gt;</code></pre>
<h3 id="repeat">repeat()</h3>
<pre><code>let meinString = "ECMAScript6;";
console.log(meinString.repeat(1)); // Ausgabe: ECMAScript6;
console.log(meinString.repeat(2)); // Ausgabe: ECMAScript6;ECMAScript6;
console.log(meinString.repeat(3)); // Ausgabe: ECMAScript6;ECMAScript6;ECMAScript6;
&lt;!--index_972.html --&gt;</code></pre>
<h2 id="andere-verbesserungen-bei-der-arbeite-mit-regularen-ausdruck">Andere Verbesserungen bei der Arbeite mit regulären Ausdrücken</h2>
<p>Reguläre Ausdrücke spielen in JavaScript eine große Rolle. </p>
<h3 id="y-flag">y-Flag</h3>
<pre><code>
&lt;!--index_971.html --&gt;</code></pre>
<p><a href="https://stackoverflow.com/questions/4542304/what-does-regex-flag-y-do">https://stackoverflow.com/questions/4542304/what-does-regex-flag-y-do</a></p>
<h3 id="duplizieren">Duplizieren</h3>
<blockquote>
<p>Das g-Flag steht für die globale Suche. Globale Suche bedeutet, dass alle 
Überenstimmungen gefunden werden - abhängig von der Groß- oder Kleinschreibung. 
Das i-Flag sucht Überenstimmungen unabhängig von der Groß- oder Kleinschreibung.</p>
</blockquote>
<pre><code>let rexWithi = /ab/i;
let rexWithg = new RegExp(rexWithi, "g");

console.log(rexWithi.toString()); // Ausgabe: /ab/i
console.log(rexWithg.toString()); // Ausgabe: /ab/g

console.log(rexWithi.test("ab")); // Ausgabe: true
console.log(rexWithg.test("ab")); // Ausgabe: true

console.log(rexWithi.test("AB")); // Ausgabe: true
console.log(rexWithg.test("AB")); // Ausgabe: false
&lt;!--index_970.html --&gt;</code></pre>
<h3 id="flag-eigenschaften">Flag-Eigenschaften</h3>
<pre><code>let rex = /ab/iu;
console.log(rex.toString()); // Ausgabe: /ab/i

// ECMAScript 5
console.log(
        rex.toString().substring(
        rex.toString().lastIndexOf("/") + 1, rex.length
        )); // Ausgabe: iu

// ECMAScript 6
console.log(rex.source); // Ausgabe: ab
console.log(rex.flags); // Ausgabe: iu
&lt;!--index_969.html --&gt;</code></pre>
<h2 id="template-strings">Template-Strings</h2>
<p><a href="https://de.wikipedia.org/wiki/Dom%C3%A4nenspezifische_Sprache">https://de.wikipedia.org/wiki/Dom%C3%A4nenspezifische_Sprache</a></p>
<h3 id="syntax">Syntax</h3>
<p>Template-Strings sind anstelle von doppelten bzw. einfachen 
Anführungszeichen in Back-Ticks (<code> </code>) (grave accent) eingeschlossen. 
Template-Strings können Platzhalter beinhalten, die durch 
das Dollarsymbol gefolgt von geschweiften Klammern gekennzeichnet 
sind (${expression}).
<a href="https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/template_strings">https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/template_strings</a></p>
<pre><code>
&lt;!--index_968.html --&gt;</code></pre>
<h3 id="multiline">Multiline</h3>
<p>Vor ECMAScript 6 war es nur auf Umwegen möglich eine Zeichenkette auf 
mehrere Zeilen zu verteilen.</p>
<pre><code>
&lt;!--index_967.html --&gt;</code></pre>
<pre><code>
&lt;!--index_966.html --&gt;</code></pre>
<h3 id="ersetzungen">Ersetzungen</h3>
<pre><code>
&lt;!--index_965.html --&gt;</code></pre>
<h3 id="tagged">Tagged</h3>
<pre><code>
&lt;!--index_964.html --&gt;</code></pre>
<blockquote>
<p><strong>Achtung:</strong></p>
</blockquote>
<h2 id="diesem-kapitel-haben-wir">In diesem Kapitel haben wir ...</h2>
<p>xxx</p>
<div class="footnotes">
<hr />
<ol>
</ol>
</div><h1 id="ecmascript-6-funktionen">ECMAScript 6 - Funktionen</h1>
<p><a href="#" id="Funktionen"></a></p>
<h2 id="diesem-kapitel-werden-wir">In diesem Kapitel werden wir …</h2>
<p>Zunächst zeige ich Ihnen, wie Sie 
Todo Meldungen immer mit Firefox</p>
<h2 id="standardwerte">Standardwerte</h2>
<h3 id="ecmascript-5">ECMAScript 5</h3>
<pre><code>function standardwert(variable1, timeout){
timeout = timeout || 1000;
...
}</code></pre>
<pre><code>
&lt;!--index_963.html --&gt;</code></pre>
<h3 id="ecmascript-6">ECMAScript 6</h3>
<p>ECMAScript 6 vereinfacht die die Zuweisung eines Standardwertes. Zusätzlich 
ist diese Art der Zuweisung übersichtlicher.</p>
<pre><code>
&lt;!--index_962.html --&gt;</code></pre>
<p>Imn nächsten Beispiel wird Standardparameter gesetzt.</p>
<pre><code>
&lt;!--index_961.html --&gt;</code></pre>
<h3 id="auswirkungen-auf-arguments-objekt">Auswirkungen auf Arguments Objekt</h3>
<pre><code>
&lt;!--index_960.html --&gt;</code></pre>
<blockquote>
<p>Mit ECMAScript 5 wurde der strict mode eingeführt, welcher inzwischen 
in allen gängigen Web-Browsern - inklusive dem  IE10 - implementiert wurde. 
Es ist einfach, im Web-Browser zum <em>Strict mode</em> zu 
wechseln - es genügt, die Zeile <code>"use strict";</code> am Anfang des 
Quellcodes hinzufügen. 
Der strikte Modus ist eine 
Möglichkeit, sich für eine eingeschränkte Variante von JavaScript 
zu entscheiden. Hierdurch wird der <em>Sloppy Mode (schlampige Modus)</em> 
deaktiviert. <em>Sloppy Mode</em> ist der inoffizielle Name des 
Standardmodus von ECMAScript 5.
<a href="https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Strict_mode">https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Strict_mode</a></p>
</blockquote>
<pre><code>
&lt;!--index_960a.html --&gt;</code></pre>
<p>Wenn ein Standardparameter gesetzt wird, wir automatisch in den strict mode 
geschaltet.</p>
<pre><code>
&lt;!--index_959.html --&gt;</code></pre>
<h3 id="expressions">Expressions</h3>
<p>Sie können mithilfe einer Funktion einen Standardwert 
setzen. Dies ist meiner Meinung nach eine der spannendsten neuen 
Möglichkeiten.</p>
<pre><code>
&lt;!--index_958.html --&gt;</code></pre>
<p>So ist es möglich, einen Wert zu unterschiedliche Zeiten unterschiedlich 
zu setzten.</p>
<pre><code>
&lt;!--index_958a.html --&gt;</code></pre>
<p>Dies ist die Überleitung zu einer anderen sinnvollen Fähigkeit. Sie können 
einen eine Variable standardmäßig mit dem aktuellen Wert einer anderen Variable 
belegen.</p>
<pre><code>
&lt;!--index_958b.html --&gt;</code></pre>
<p>Weitergedacht</p>
<pre><code>
&lt;!--index_958c.html --&gt;</code></pre>
<p>Das geht nicht </p>
<pre><code>
&lt;!--index_958d.html --&gt;</code></pre>
<h3 id="tdz">TDZ</h3>
<p>Die TDZ war im ersten Kapitel im Zusammenhang mit <code>let</code> und <code>const</code> schon einmal 
Thema.</p>
<p>958c aus Sicht des JavaScript Compilers</p>
<pre><code>
&lt;!--index_957.html --&gt;</code></pre>
<p>958d aus Sicht des JavaScript Compilers</p>
<pre><code>
&lt;!--index_956.html --&gt;</code></pre>
<h2 id="unnamed-functions">Unnamed functions</h2>
<p>In den bisherigen Beispielen sind nur Funktionsparameter vorgekommen, die 
mit einem Namen in der Funktions-Signatur eingefügt wurden.</p>
<blockquote>
<p>Typisch für eine Funktion ist die sogenannte Signatur oder Schnittstelle. 
Darunter versteht man die genaue Art und Weise, mit der die Funktion 
aufgerufen wird. 
<code>Todo funktion einfügen</code>
Die Signatur der Funktion ist die oberste Zeile. Früher sagte man auch 
<em>Funktionskopf</em>. Viele Informatiker bezeichnen die oberste Zeile auch 
als <em>Interface</em> oder auf Deutsch <em>Schnittstelle</em>.</p>
</blockquote>
<p>Schon in ECMAScript 5 war es möglich mit optionalen Parametern zu arbeiten. 
ECMAScript 6 macht das Arbeiten mit optionalen Parametern einfacher.</p>
<h3 id="ecmascript-5">ECMAScript 5</h3>
<p>Optionale Parameter in ECMAScript 5</p>
<pre><code>
&lt;!--index_955.html --&gt;</code></pre>
<h3 id="rest-parameter">Rest Parameter</h3>
<p>Was ist Rest Parameter? </p>
<blockquote>
<p>Der Operator ... besitzt zwei grundsätzlich verschiedene Bedeutungen. 
Abhängig davon, in welchem Kontext er notiert wird, dient er entweder als 
Rest-Operator oder als Spread-Operator. 
Der erstgenannte Rest-Operator kann zur Erstellung von Restparametern 
genutzt werden.
<a href="https://wiki.selfhtml.org/wiki/JavaScript/Operatoren/Rest-_oder_Spread-Operator">https://wiki.selfhtml.org/wiki/JavaScript/Operatoren/Rest-_oder_Spread-Operator</a>
Mithilfe eines Restparameters kann man beliebig viele 
Parameter als Array empfangen.
<a href="https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Functions/rest_parameter">https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Functions/rest_parameter</a></p>
</blockquote>
<pre><code>
&lt;!--index_954.html --&gt;</code></pre>
<h4 id="beschrankungen">Beschränkungen</h4>
<p>Es darf nur einen geben und er muss an letzter Stelle stehen.</p>
<pre><code>
&lt;!--index_953a.html --&gt;</code></pre>
<p>In einer Setter Methode ist ein Rest Parameter nicht möglich.</p>
<pre><code>
&lt;!--index_953b.html --&gt;</code></pre>
<h4 id="auswirkungen-auf-das-arguments-objekt">Auswirkungen auf das arguments-Objekt</h4>
<blockquote>
<p>Das arguments-Objekt ist ein Array-ähnliches Objekt, das auf 
die übergebenen Parameter einer Funktion verweist. 
Das arguments-Objekt ist eine lokal verfügbare Variable in allen 
(Nicht-Pfeil-) Funktionen. Man kann auf die Parameter einer Funktion 
referenzieren, wenn man in einer Funktion das arguments-Objekt benutzt. 
Dieses Objekt enthält einen Eintrag für jeden übergebenen Parameter 
der Funktion. Der erste Eintrag beginnt beim Index 0. 
Wenn einer Funktion drei Parameter übergeben werden, kann wie folgt auf 
diese zugegriffen werden;</p>
</blockquote>
<pre><code>arguments[0]
arguments[1]
arguments[2]</code></pre>
<p><a href="https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Functions/arguments">https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Functions/arguments</a></p>
<p>Das arguments-Objekt spiegelt das Rest Objekt wider.</p>
<pre><code>
&lt;!--index_952.html --&gt;</code></pre>
<h2 id="konstruktor">Konstruktor</h2>
<p>Der <code>Function</code>-Konstruktor erstellt ein neues Funktions-Objekt. 
Dieser Konstruktor wird in der Praxis selten verwendet. 
<a href="https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Function">https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Function</a></p>
<p>Der folgende Code erstellt ein Funktions-Objekt, mit zwei Parametern. 
Die Parameter <code>variable1</code> und <code>variable2</code> sind formale Parameternamen, 
welche im Funktionskörper genutzt werden, <code>return variable1 + variable2</code>.</p>
<pre><code>
&lt;!--index_951.html --&gt;</code></pre>
<blockquote>
<p>Es gibt oft Verwirrung zwischen den Begriffen Parameter und Argumente. 
Dabei ist es ganz einfach: Die Werte, die man beim Aufruf an eine 
Funktion übergibt, sind die Argumente. Die Variablen, in denen 
die Argumente dann innerhalb der Funktion zur Verfügung stehen, sind 
die Parameter. <a href="https://wiki.selfhtml.org/index.php?title=JavaScript/Funktion&amp;oldid=59542">https://wiki.selfhtml.org/index.php?title=JavaScript/Funktion&amp;oldid=59542</a></p>
</blockquote>
<p>Mit ECMAScript 6 ist es möglich, im <code>Function</code>-Konstruktor Standardwerte für 
einen Paramameter zu setzten.</p>
<pre><code>ECMAScript 6 ünterstützt Rest Parameter

&lt;!--index_951a.html --&gt;</code></pre>
<pre><code>
&lt;!--index_951b.html --&gt;</code></pre>
<h2 id="spread-operator">Spread Operator</h2>
<blockquote>
<p>Der Operator ... besitzt zwei grundsätzlich verschiedene Bedeutungen. 
Abhängig davon, in welchem Kontext er notiert wird, dient er entweder als 
Rest-Operator oder als Spread-Operator. Mit dem Spread-Operator 
ist es möglich, die Elemente eines iterierbaren Objektes in ein Array 
oder eine Liste mit Argumenten einzufügen. 
<a href="https://wiki.selfhtml.org/wiki/JavaScript/Operatoren/Rest-_oder_Spread-Operator">https://wiki.selfhtml.org/wiki/JavaScript/Operatoren/Rest-_oder_Spread-Operator</a></p>
</blockquote>
<p>Ich bin ein großer Fan des Spread-Operators. Im Folgenden finden Sie 
eines meiner bevorzugten 
Verwendungen des Spread-Operators in JavaScript! Weitere Beispiel 
können Sie bei <a href="https://davidwalsh.name/spread-operator">https://davidwalsh.name/spread-operator</a> nachlesen.</p>
<p>Bis ECMAScript 5 haben wir die Function.prototype.apply aufgerufen, 
indem wir ein Array von Argumenten übergeben, um eine Funktion mit einem 
gegebenen Satz von Parametern in einem Array aufzurufen.</p>
<pre><code>
&lt;!--index_950.html --&gt;</code></pre>
<p>Mithilfe des Spread-Operators können wir die Verwendung der Funktion 
apply() vermeiden und die eigentliche Funktion mit 
dem Array aufrufen. Wir fügen nur vor das Array den Spread-Operator ein - also die 
drei Punkte.</p>
<pre><code>
&lt;!--index_950a.html --&gt;</code></pre>
<p>Der Spread-Operator kann mit anderen Parametern gemischt werden.</p>
<pre><code>
&lt;!--index_950b.html --&gt;</code></pre>
<h2 id="spezialfall-die-eigenschaft-name">Spezialfall: Die Eigenschaft Name</h2>
<p>Es ist einfach Funktionen in JavaScript allen Funktionen einen guten Namen 
zu geben. ECMAScript 6 geht noch einen Schritt weiter. Seit ECMAScript 6 
ist sichergestellt, dass alle Funktionen einen Namen haben. </p>
<h3 id="passende-namen-wahlen">Passende Namen wählen</h3>
<pre><code>
&lt;!--index_949.html --&gt;</code></pre>
<h3 id="spezielle-falle">Spezielle Fälle</h3>
<p>getter, funktion in Variable, ...
<a href="https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Function/name">https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Function/name</a></p>
<pre><code>
&lt;!--index_949a.html --&gt;  passt nicht zur Erklärgun</code></pre>
<p>bind und anonym</p>
<pre><code>
&lt;!--index_949b.html --&gt;  passt nicht zur Erklärgun</code></pre>
<blockquote>
<p>Jede Funktion besitzt eine bind() Methode. Mit dieser können wir unserer 
Funktion einen neuen Kontext zuweisen. 
Der erste Parameter fungiert als neuer Kontext "this". 
Zusätzlich können weitere Parameter übergeben werden diese werden an die 
Funktion weitergereicht. Sehr wichtig: Die bind() methode ruft die 
Funktion nicht auf, sondern erzeugt eine neue Funktion.
<a href="https://alexandernaumov.de/artikel/javascript-apply-call-bind-unterschied">https://alexandernaumov.de/artikel/javascript-apply-call-bind-unterschied</a></p>
</blockquote>
<pre><code>&lt;!--index_949b.html --&gt;  exkurs bind</code></pre>
<blockquote>
<p>Die Eigenschaft Name gibt also nicht immer den Namen der Variablen zurück. Warum 
ist dies so? Die Eigenschaft soll in erste Linie beim Debuggen helfen. </p>
</blockquote>
<h2 id="funktionen-und-konstrukor">Funktionen und Konstrukor</h2>
<blockquote>
<p>Das Problem mit "this". Wer zuerst eine andere Programmiersprache gelernt 
hat als Javascript dem sollte die Eigenart von "this" aufgefallen sein. 
Das "this" in Javascript ist nicht zu verwechseln mit "this" in Java oder PHP. 
Im PHP ist "$this" stets eine Referenz auf das Objekt zu welchem es gehört. 
In JavaScript dagegen ist es eine Referenz auf den Kontext im dem die 
Funktion aufgerufen wird. Im Klartext: "this" im Javascript hängt immer 
davon ab "wo" und "wie" die Funktion aufgerufen wird. 
(<a href="https://alexandernaumov.de/artikel/javascript-apply-call-bind-unterschied">https://alexandernaumov.de/artikel/javascript-apply-call-bind-unterschied</a>)</p>
</blockquote>
<p>Funktionen können in JavaScript mit new und ohne new aufgerufen werden.</p>
<pre><code>&lt;!--index_948.html --&gt;  exkurs bind</code></pre>
<h3 id="ecmascript-5-testen-new-genutzt-wurde">ECMAScript 5 - Testen of new genutzt wurde</h3>
<pre><code>&lt;!--index_948a.html --&gt;  exkurs bind</code></pre>
<p>Aber call und apply ist möglich</p>
<pre><code>&lt;!--index_948b.html --&gt;  exkurs bind</code></pre>
<blockquote>
<p>Exkurs. Return nutzen wenn Variabele auch belegt sein soll.</p>
<pre><code>&lt;!--index_948c.html --&gt;  exkurs bind</code></pre>
</blockquote>
<h3 id="ecmascript-6-testen-new-genutzt-wurde-newtarget">ECMAScript 6 - Testen of new genutzt wurde - new.target</h3>
<pre><code>&lt;!--index_947.html --&gt;  exkurs bind</code></pre>
<p>new.target === Person ist unnötig, oder?</p>
<pre><code>unnötig, oder?
&lt;!--index_947a.html --&gt;  exkurs bind</code></pre>
<h2 id="block-level-funktionen">Block Level Funktionen</h2>
<p>ECMAScript 5 Brwoser behandelt funktionen innerhalb von funktionen anders. 
Deshalb hat strict mode es nicht erlaubt. mit ECMAScript 6 ist es möglich.</p>
<pre><code>
&lt;!--index_946.html --&gt;  exkurs bind</code></pre>
<h3 id="wann-block-level-funktionen-verwenden">Wann Block Level Funktionen verwenden</h3>
<p>Block Level Funktionen werden nach oben geschoben. Wenn Sie let nutzen nicht.</p>
<pre><code>
&lt;!--index_945.html --&gt;  exkurs bind</code></pre>
<h3 id="non-strict-mode">Non Strict Mode</h3>
<p>Die Funktion ist im globalen Kontext sichtbar.</p>
<pre><code>
&lt;!--index_944.html --&gt;</code></pre>
<h2 id="pfeilfunktionen-arrow-funktions">Pfeilfunktionen - Arrow Funktions</h2>
<p>Der Ausdruck einer Pfeilfunktion hat eine kürzere Syntax als ein Funktionsausdruck. </p>
<p><a href="https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Functions/Pfeilfunktionen">https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Functions/Pfeilfunktionen</a></p>
<ul>
<li>kein eigenes this, arguments, super, oder new.target (super kommt später).</li>
<li>Pfeilfunktionen können nicht als Konstruktoren verwendet werden. Sie führen zu einem Fehler, wenn auf ihnen ein new angewendet wird.</li>
<li>Pfeilfunktionen haben keine prototype Eigenschaft.</li>
<li>Da this in Pfeilfunktionen nicht gebunden ist, können call() oder apply() Methoden nur Argumente übergeben; this wird ignoriert.</li>
<li>Pfeilfunktionen haben kein eigenes arguments Objekt. Somit ist arguments einfach eine Referenz auf den Namen innerhalb des umschließenden Geltungsbereichs (scope).</li>
<li>Es sind keine doppelten Parameterenamn möglich.</li>
</ul>
<h3 id="syntax">Syntax</h3>
<p>Die Syntax von Pfeilfunktion ist nicht fix. Jenachdem ob Sie Parameter übergeben 
möchten und wenn ja, wie viele können die nachfolgenden Varianten vorkommen.</p>
<p>Die Übergabe eines Parameters.</p>
<pre><code>let meinePfeilfunktion1 = value =&gt; value;
// ist gleichwertig mit
let meinePfeilfunktion2 = function(value) {
    return value;
};
console.log(meinePfeilfunktion1);
console.log(meinePfeilfunktion2);
console.log(meinePfeilfunktion1(13)); // Ausgabe: 13
console.log(meinePfeilfunktion2(13)); // Ausgabe: 13
&lt;!--index_943.html --&gt; </code></pre>
<blockquote>
<p>Hier sehen Sie auch 
<img src="./media/kap3_1.png" alt="alt text" /> todo bild kleiner machen</p>
</blockquote>
<p>Wenn Sie mehr als einen Parameter an die Funktion übergeben möchten.</p>
<pre><code>let meinePfeilfunktion1 = (eins, zwei) =&gt; eins + zwei;
// ist gleichwertig mit
let meinePfeilfunktion2 = function(eins, zwei) {
    return eins + zwei;
};
console.log(meinePfeilfunktion1);
console.log(meinePfeilfunktion2);
console.log(meinePfeilfunktion1(1, 2)); // Ausgabe: 3
console.log(meinePfeilfunktion2(1, 2)); // Ausgabe: 3
&lt;!--index_943a.html --&gt; </code></pre>
<p>Sie möchten gar keinen Parameter übergeben? </p>
<pre><code>let meinePfeilfunktion1 = () =&gt; "Ausgabe1";
// ist gleichwertig mit
let meinePfeilfunktion2 = function() {
    return "Ausgabe2";
};
console.log(meinePfeilfunktion1);
console.log(meinePfeilfunktion2);
console.log(meinePfeilfunktion1()); // Ausgabe: Ausgabe1
console.log(meinePfeilfunktion2()); // Ausgabe: Ausgabe2
&lt;!--index_943b.html --&gt; </code></pre>
<p>Ihnen ist ein traditioneller Funktionsrumpf lieber?</p>
<pre><code>let meinePfeilfunktion1 = (eins, zwei) =&gt; {
    return eins + zwei;
}
// ist gleichwertig mit
let meinePfeilfunktion2 = function(eins, zwei) {
    return eins + zwei;
};
console.log(meinePfeilfunktion1);
console.log(meinePfeilfunktion2);
console.log(meinePfeilfunktion1(1, 2)); // Ausgabe: 3
console.log(meinePfeilfunktion2(1, 2)); // Ausgabe: 3
&lt;!--index_943c.html --&gt; </code></pre>
<p>Ein extremes Beispiel, das nichts tut.</p>
<pre><code>let meinePfeilfunktion1 = () =&gt; {};
// ist gleichwertig mit
let meinePfeilfunktion2 = function() {};
&lt;!--index_943d.html --&gt; </code></pre>
<p>Geschweifte Klammern markieren den Funktionsrumpf.</p>
<pre><code>let meinePfeilfunktion1 = value =&gt; ({ value: value, name: "Name"})
// ist gleichwertig mit
let meinePfeilfunktion2 = function(value) {
return { value: value, name: "Name"};
};
&lt;!--index_943e.html --&gt; </code></pre>
<p>So, nun haben wir die Syntax abgehakt.</p>
<h3 id="erstelle-iife">Erstelle IIFE</h3>
<p>In Kapitel 1 hatte ich schon erwähnt, dass IIFE häufig in JavaScript verwendet 
werden. Zur Wiederholung: IIFEs ermöglichen es eine anonyme Funktion zu 
definieren und diese sofort auszuführen ohne eine Referenz zu speichern. 
IIFEs sind praktisch, wenn Sie Variablen in einem Gültigkeitsbereich 
erstellen möchten, der von dem Rest des Programms unabhängig ist. Zum 
Beispiel so wie im nachfolgenden Programmcodebeispiel. In diesem Beispiel wird 
ein Objekt mithilfe der Methode <code>getName()</code> erstellt. Die Methode <code>getName()</code> 
nutzt den Parameter <code>name</code> als Rückgabewert.</p>
<pre><code>let person = function(name){
return {
getName: function() {
return name;
}
}
}("Astrid");
console.log(person.getName()); // Ausgabe: Astrid
&lt;!--index_942.html --&gt; </code></pre>
<p>Das gleiche Ergebnis lässt sich auch mit einer Pfeilfunktion umsetzen.</p>
<pre><code>let person = ((name) =&gt; {
return {
getName: function() {
return name;
}
};
})("Astrid");
console.log(person.getName()); // Ausgabe: Astrid
&lt;!--index_942a.html --&gt; </code></pre>
<h3 id="no-binding">No this Binding</h3>
<p>Meiner Meinung nach ist die Verwendung von <code>this</code> eine der größen 
Fehlerquellen in JavaScript. Viele Entwickler tun sich schwer zu erkennen 
was gerade genau <code>this</code> ist. Außerdem kann <code>this</code> innerhalb ein und derselben 
Funktion auf etwas anderes verweisen - jenachdem in welchem Kontext die 
Funktion gerade aufgerufen wird. Das nächste Prgrammcodebeispiel 
veranschaulicht diese Problematik.</p>
<pre><code>let Seitenbearbeiter = {
id: "1000",
init: function() {
document.addEventListener("click", function(event) {
this.doSomething(event.type);
}, false);
},
doSomething: function(type) {
console.log("Bearbeite " + type  + " für " + this.id);
}
};
Seitenbearbeiter.init(); // Ausgabe falls du auf die Seite klickst: 
                         // TypeError: this.doSomething is not a function
Seitenbearbeiter.doSomething("Test"); // Ausgabe: Bearbeite Test für 1000
&lt;!--index_941.html --&gt; </code></pre>
<p>Das nächste Programmcodebeispiel zeigt ein mögliche Lösung für das Problem 
des vorherigen Beispiels. Der Code arbeitet nun korrekt. Er ist allerdings 
nicht sehr intuitiv. <code>bind(this)</code> erstellt eine neue Funktion die <code>this</code> 
bindet.</p>
<pre><code>let Seitenbearbeiter = {
id: "1000",
init: function() {
document.addEventListener("click", (function(event) {
this.doSomething(event.type);
}).bind(this), false);
},
doSomething: function(type) {
console.log("Bearbeite " + type  + " für " + this.id);
}
};
Seitenbearbeiter.init(); // Ausgabe: Bearbeite click für 1000
Seitenbearbeiter.doSomething("Test"); // Ausgabe: Bearbeite Test für 1000
&lt;!--index_941a.html --&gt; </code></pre>
<p>Pfeilfunktionen binden <code>this</code> nicht.</p>
<pre><code>let Seitenbearbeiter = {
id: "1000",
init: function() {
document.addEventListener("click", 
event =&gt; this.doSomething(event.type), false);
},
doSomething: function(type) {
console.log("Bearbeite " + type  + " für " + this.id);
}
};
Seitenbearbeiter.init(); // Ausgabe: Bearbeite click für 1000
Seitenbearbeiter.doSomething("Test"); // Ausgabe: Bearbeite Test für 1000
&lt;!--index_941b.html --&gt; </code></pre>
<p>Pfeilfunktionen können nicht mit new genutzt werden.</p>
<pre><code>let MeinTyp = () =&gt; {};
let meinObjekt = new MeinTyp(); // Ausgabe: TypeError: MeinTyp is not a constructor
&lt;!--index_940.html --&gt; </code></pre>
<h3 id="pfeilfunktionen-und-arrays">Pfeilfunktionen und Arrays</h3>
<pre><code>let values = [20, 10, 30];
let ergebnis = values.sort(function(a, b) {
return a - b;
});
console.log(ergebnis); // Ausgabe: Array(3) [ 10, 20, 30 ]
&lt;!--index_939.html --&gt; </code></pre>
<pre><code>let values = [20, 10, 30];
let ergebnis = values.sort((a, b) =&gt; a - b);
console.log(ergebnis); // Ausgabe: Array(3) [ 10, 20, 30 ]
&lt;!--index_939a.html --&gt; </code></pre>
<h3 id="no-arguments-binding">No arguments binding</h3>
<p>Eine Pfeilfunktion hat kein eigenen <code>arguments</code>-Objekt. Zur Erinnerung: 
Das <code>arguments</code>-Objekt ist ein Array-ähnliches Objekt, 
das auf die übergebenen Parameter einer Funktion verweist.<br />
Eine Pfeilfunktion kann trotzdem über ein <code>arguments</code>-Objekt verfügen. Nämlich 
dann, wenn die Pfeilfunktion von einer anderen Funktion aufgerufen wird. In 
diesem Fall verfügt die Pfeilfunktion über das <code>arguments</code>-Objekt der 
übergebenden Funktion.</p>
<pre><code>function getErstesArgument() {
return () =&gt; arguments[0];
}
let pfeilfunktion = getErstesArgument("eins");
console.log(pfeilfunktion()); // Ausgabe: eins
&lt;!--index_938.html --&gt; </code></pre>
<p>Wäre die Pfeilfunktion des vorhergehenden Beispiels als normale Funktion 
implementiert, sähe das Ergebnis anders aus. Überzeugen Sie sich sich selbst 
davon und sehen Sie sich das nächsten Programmcodebeispiel an. </p>
<pre><code>function getErstesArgument() {
return function () { return arguments[0];};
}
let pfeilfunktion = getErstesArgument("eins");
console.log(pfeilfunktion()); // Ausgabe: undefined
&lt;!--index_938a.html --&gt; </code></pre>
<h3 id="identify-arrow-functions">Identify Arrow Functions</h3>
<p>Eine Pfeilfunktion ist trotz aller Besonderheiten eine Funktion und wird 
in JavaScript auch so identifiziert. Überzeugen Sie sich selbst beim Nachvollziehen 
der beiden nachfolgenden Programmcodebeispiele.</p>
<pre><code>let pfeilfunktion = (a, b) =&gt; a - b;
console.log(typeof pfeilfunktion); // Ausgabe: function
console.log(pfeilfunktion instanceof Function); // Ausgabe: true
&lt;!--index_937.html --&gt; </code></pre>
<p>Auch die Funktionen call, apply und bind können mit einer Pfeilfunktion 
verwendet werden - abgesehen davon, dass <code>this</code> den Kontext nicht verändert.</p>
<pre><code>let pfeilfunktion = (a, b) =&gt; a - b;
console.log(pfeilfunktion.call(null, 5, 4)); // Ausgabe: 1
console.log(pfeilfunktion.apply(null, [5, 4])); // Ausgabe: 1

console.log(pfeilfunktion.bind(null, 5, 4)()); // Ausgabe: 1
// gleiwertig zu
let pfeilfunktion2 = pfeilfunktion.bind(null, 5, 4);
console.log(pfeilfunktion2()); // Ausgabe: 1
&lt;!--index_937a.html --&gt; </code></pre>
<h2 id="optimierung-der-endrekursion">Optimierung der Endrekursion</h2>
<p>Eine rekursive Funktion ist endrekursiv (englisch tail recursive), 
wenn der rekursive Funktionsaufruf die letzte Aktion zur Berechnung von 
der Funktion ist. </p>
<blockquote>
<p>Weitere Informationen zu endrekursiven Funktionen finden Sie unter anderem bei 
<a href="https://de.wikipedia.org/w/index.php?title=Endrekursion&amp;oldid=173836523">Wikipedia</a></p>
</blockquote>
<p>Endrekursive Funktionen werden bis ECMAScript 5 wie ganz normale Funktionen 
behandelt. Ein neues Stack Frame wird erstellt und zum 
<a href="https://de.wikipedia.org/w/index.php?title=Aufrufstapel&amp;oldid=182386193">Aufrufstapel (englisch call stack)</a> 
hinzugefügt. Jedes neue Stack Frame füllt also den Arbeitsspeicher während die 
vorhergehenden Stack Frames weiterhin vorhanden sind. Je nach Komplexität des 
Aufufs kann dies zu Speicherproblemen führen - der Arbeitsspeicher kann 
volllaufen.</p>
<h3 id="endrekursion-ecmascript-6">Endrekursion in ECMAScript 6</h3>
<p>Endrekursion ist optimiert, wenn folgende Kriterien zutreffen:</p>
<ul>
<li>strict mode</li>
<li>Die Funktion ist kein Closure (todo was ist das)</li>
<li>Nach dem Return gibt keine weitere Rechenaufgabe</li>
<li>Das Ergebnis wird am Ende der Funktion zurückgegeben</li>
</ul>
<p>Ein Beispiel sagt oft mehr als 1000 Worte. Ein Beispiel für die Verwendung 
einer rekursiven Programmierung ist die Berechnung der Fakultät einer Zahl.</p>
<blockquote>
<p>Die Fakultät ist in der Mathematik eine Funktion, die einer natürlichen 
Zahl das Produkt aller natürlichen Zahlen (ohne Null) kleiner und gleich 
dieser Zahl zuordnet. <a href="https://de.wikipedia.org/wiki/Fakult%C3%A4t_(Mathematik">https://de.wikipedia.org/wiki/Fakult%C3%A4t_(Mathematik</a>) 
<img src="./media/kap3_2.png" alt="Fakultät" /></p>
</blockquote>
<p>Das folgende Beispiel erfüllt alle Kriterien und kann optimiert ausgeführt werden. </p>
<pre><code>"use strict";
function fakultaet(n, m = 1) {
if (n &lt;= 1){
return 1 * m;    
} else {
let ergebnis = n * m;    
return fakultaet(n-1, ergebnis);     
}
}
console.log(fakultaet(5)); // Ausgabe: 120
&lt;!--index_936.html --&gt; </code></pre>
<p>Noch Rechnung nach Return notwendig</p>
<pre><code>"use strict";
function fakultaet(n) {
if (n &lt;= 1){
return 1;    
} else {
return n * fakultaet(n-1);     
}
}
console.log(fakultaet(5)); // Ausgabe: 120
&lt;!--index_936a.html --&gt; </code></pre>
<p>Kein Return</p>
<pre><code>"use strict";
let ergebnis = 1;    
function fakultaet(n) {
if (n &lt;= 1){
ergebnis = ergebnis;    
} else {
ergebnis = ergebnis * n;  
fakultaet(n-1);     
}
}
fakultaet(5);
console.log(ergebnis); // Ausgabe: 120
&lt;!--index_936b.html --&gt; </code></pre>
<p>Closure</p>
<pre><code>"use strict";
function umrahmung(a) {
let nummer = 1;    
function fakultaet(n) {
if (n &lt;= 1){
return 1;    
} else { 
return n * fakultaet(n-1);     
}
}
return fakultaet(a)
}
console.log(umrahmung(5)); // Ausgabe: 120
&lt;!--index_936c.html --&gt; </code></pre>
<pre><code>
&lt;!--index_964.html --&gt;</code></pre>
<blockquote>
<p><strong>Achtung:</strong></p>
</blockquote>
<h2 id="diesem-kapitel-haben-wir">In diesem Kapitel haben wir ...</h2>
<p>xxx</p>
<p>todo <a href="https://github.com/woota/FE-training-examples/blob/master/es6/4.%20Arrow-Functions.md">https://github.com/woota/FE-training-examples/blob/master/es6/4.%20Arrow-Functions.md</a></p>
<div class="footnotes">
<hr />
<ol>
</ol>
</div><h1 id="ecmascript-6-objekte">ECMAScript 6 - Objekte</h1>
<p><a href="#" id="Objekte"></a></p>
<h2 id="diesem-kapitel-werden-wir">In diesem Kapitel werden wir …</h2>
<p>ECMAScript 6 verbessert die Arbeit mit Objekten.</p>
<h2 id="welche-objekte-gib-es-javascript">Welche Objekte gib es in JavaScript</h2>
<h2 id="syntax">Syntax</h2>
<p>Die populärste Variante ein Objekt in JavaScript zu erzeugen, ist der 
<code>Objekt-Literal</code>. 
Die Syntax des <code>Objekt-Literals</code> beginnt mit einer öffnenden 
geschweiften Klammer <code>{</code> und endet mit einer 
schließenden geschweiften Klammer <code>}</code>. Dazwischen werden die 
Eigenschaften mit Name und Wert aufgelistet. 
Zwischen dem Name der Eigenschaft und ihrem Wert steht ein 
Doppelpunkt, zwischen den Eigenschaften selbst ein Komma. 
JSON baut auf dieser Syntax auf. Das Erfolgsrezept dieser Syntax ist 
die Einfachheit, mit der ein Objekt erstellt wird. 
ECMAScript 6 verbessert das Arbeiten mit <code>Objekt-Literalen</code> noch weiter.</p>
<h3 id="abgekurzte-syntax-fur-eigenschaften">Abgekürzte Syntax für Eigenschaften</h3>
<p>Schon in ECMAScript 5 reichten einige wenige Zeilen um ein Objekt zu erstellen. 
Im nächsten Beispiel können Sie sich davon überzeugen.</p>
<pre><code>function erstellePerson(name, alter) {
return {
name: name,
alter: alter
};
}
let person = erstellePerson("Astrid", 50);
console.log(person); // Ausgabe: Object { name: "Astrid", alter: 50 }
&lt;!--index_935.html --&gt;</code></pre>
<p>Mit ECMAScript 6 wird der notwendige Programmcode noch weiter reduziert. Das 
nachfolgende Beispiel ist das ECMAScript 6 Äquivalent zum vorhergenden 
Beispiel. Sehen Sie selbst, die Namen der Eigenschaften können Sie 
im Objekt-Literal` einsparen solange Sie die Variablen die passenden Namen 
haben.</p>
<p>Im nächsten Beispiel haben die Variablen die gleichen Namen und 
die gleiche Reihenfolge wie im vorhergehenden.</p>
<pre><code>function erstellePerson(name, alter) {
return {
name,
alter
};
}
let person = erstellePerson("Astrid", 50);
console.log(person); // Ausgabe: Object { name: "Astrid", alter: 50 }
&lt;!--index_935a.html --&gt;</code></pre>
<p>Nachfolgend können Sie sehen was passiert, wenn Sie die Variablen in 
einer anderen Reihenfolge eingeben.</p>
<pre><code>function erstellePerson(name, alter) {
return {
alter,
name
};
}
let person = erstellePerson("Astrid", 50);
console.log(person); // Ausgabe: Object { alter: 50, name: "Astrid" }
&lt;!--index_935b.html --&gt;</code></pre>
<p>Wenn sie andere Variablennamen verwenden, wird ihr Ergebnis ein Objekt 
mit anderen Eigenschaften sein.</p>
<pre><code>function erstellePerson(name, alter) {
let age = alter;    
return {
age,
name
};
}
let person = erstellePerson("Astrid", 50);
console.log(person); // Ausgabe: Object { age: 50, name: "Astrid" }
&lt;!--index_935c.html --&gt;</code></pre>
<h3 id="abgekurzte-syntax-fur-methoden">Abgekürzte Syntax für Methoden</h3>
<p>Auch Methoden können Sie in abgekürzter Form in einem <code>Object-Literal</code> 
verwenden.</p>
<pre><code>&lt;!--index_934.html --&gt;</code></pre>
<pre><code>&lt;!--index_934a.html --&gt;</code></pre>
<h3 id="namen-von-eigenschaften-im-objekt-literal">Namen von Eigenschaften im Objekt-Literal</h3>
<p>Die Namen von Eigenschaften konnten nicht berechnet werden.</p>
<pre><code>let person = {};
let nachname = "nach name";
person["vor name"] = "astrid";
person[nachname] = "guenther";
person["geburts name"] = "mueller";

console.log(person["vor name"]); // Ausgabe: astrid
console.log(person[nachname]); // Ausgabe: guenther
console.log(person["geburts name"]); // Ausgabe: mueller
&lt;!--index_933.html --&gt;</code></pre>
<pre><code>let nachname = "nach name";
let person = {
    "vor name": "astrid",
    nachname: "guenther",
    "geburts name": "mueller",
};

console.log(person["vor name"]); // Ausgabe: astrid
console.log(person[nachname]); // Ausgabe: undefind
console.log(person["geburts name"]); // Ausgabe: mueller
&lt;!--index_933a.html --&gt;</code></pre>
<pre><code>let nachname = "nach name";
let person = {
    "vor name": "astrid",
    "geburts name": "mueller",
};
person[nachname] = "guenther";
console.log(person["vor name"]); // Ausgabe: astrid
console.log(person[nachname]); // Ausgabe: guenther
console.log(person["geburts name"]); // Ausgabe: mueller
&lt;!--index_933b.html --&gt;</code></pre>
<p>Im Objekt-Literal können mit ECMAScript 6 eckige Klammern verwendet werden.</p>
<pre><code>let nachname = "nach name";
let person = {
    "vor name": "astrid",
    [nachname]: "guenther",
    "geburts name": "mueller",
};
console.log(person["vor name"]); // Ausgabe: astrid
console.log(person[nachname]); // Ausgabe: guenther
console.log(person["geburts name"]); // Ausgabe: mueller
&lt;!--index_933c.html --&gt;</code></pre>
<h2 id="neue-methoden">Neue Methoden</h2>
<h3 id="">is()</h3>
<p>Object.is() bestimmt, ob zwei Werte gleich sind. Dabei gelten zwei 
Werte genau dann als gleich, wenn eine der folgenden Bedingungen zutrifft:</p>
<ul>
<li>beide sind undefined</li>
<li>beide sind null</li>
<li>beide sind true oder beide sind false</li>
<li>beide sind Strings mit selber Länge und den selben Zeichen</li>
<li>beide sind das selbe Objekt</li>
<li>beide sind Zahlen und eine der folgenden Bedingungen trifft zu:<ul>
<li>beide sind +0</li>
<li>beide sind -0</li>
<li>beide sind NaN</li>
<li>beide sind nicht null, beide sind nicht NaN und beide haben den selben Zahlenwert</li>
</ul>
</li>
</ul>
<p>Dies ist nicht das selbe wie der ==-Operator. Dieser verwendet verschiedene, situationsabhängige Typ-Umwandlungen auf beiden Seiten bevor auf Gleichheit getestet wird (was z.B. dazu führt, dass der Ausdruck "" == false zu true ausgewertet wird). Object.is hingegen wandelt keinen der beiden Werte um.</p>
<p>Es ist ebenfalls nicht dasselbe wie der strikte <code>===</code>-Operator. 
Dieser – ebenso wie der <code>==</code>-Operator – behandelt zum Beispiel <code>+0</code> und <code>-0</code> als 
identisch während <code>NaN</code> und <code>NaN</code> als nicht identisch behandelt werden.
<a href="https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Object/is">https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Object/is</a></p>
<p>Jeder der Operatoren hat seine Vorteile und seine Nachteile. 
Hier gibt es kein Richtig oder Falsch. Entscheiden Sie selbst 
welcher Vergleichsoperator der 
Richtige für Ihren aktuellen Anendungsfall ist.</p>
<pre><code>console.log(0 == 0); // Ausgabe: true
console.log(0 == "0"); // Ausgabe: true
console.log(0 === 0); // Ausgabe: true
console.log(0 === "0"); // Ausgabe: false
console.log(Object.is(0, 0)); // Ausgabe: true
console.log(Object.is(0, "0")); // Ausgabe: false

console.log(+0 == -0); // Ausgabe: true
console.log(+0 === -0); // Ausgabe: true
console.log(Object.is(+0, -0)); // Ausgabe: false

console.log(NaN == NaN); // Ausgabe: false
console.log(NaN === NaN); // Ausgabe: false
console.log(Object.is(NaN, NaN)); // Ausgabe: true
&lt;!--index_932.html --&gt;</code></pre>
<h3 id="assign">assign()</h3>
<p>Die Methode Object.assign() kopiert die Werte aller aufzählbaren, eigenen Eigenschaften von einem oder mehreren Quellobjekten in ein Zielobjekt. 
Es wird das Zielobjekt zurückgegeben. <a href="https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Object/assign</a></p>
<p>Aber beginnen wir ganz vorne - hier bei Mixins. 
Ein Mixin ist eine Klasse oder eine Schnittstelle in der einige oder 
alle ihrer Methoden und/oder Eigenschaften nicht implementiert werden, 
was erfordert, dass eine andere Klasse oder Schnittstelle die fehlenden 
Implementierungen bereitstellt. 
Die neue Klasse bzw. die neue Schnittstelle enthält dann sowohl 
die Eigenschaften und Methoden aus dem Mixin als auch diejenigen, 
die sie selbst definiert. Alle Methoden und Eigenschaften werden exakt 
gleich verwendet, unabhängig davon, ob sie im Mixin implementiert 
sind oder im Interface oder in der Klasse, die das Mixin implementiert. 
Der Vorteil von Mixins besteht darin, dass sie zur Vereinfachung 
des Designs von APIs verwendet werden können, 
bei denen mehrere Schnittstellen dieselben Methoden 
und Eigenschaften enthalten müssen. <a href="https://developer.mozilla.org/de/docs/Glossary/Mixin">https://developer.mozilla.org/de/docs/Glossary/Mixin</a></p>
<p>Vielleicht ist Ihnen schon einmal ein Mixin wie das Folgende aufgefallen?</p>
<pre><code>function mixin(receiver, supplier) {
    Object.keys(supplier).forEach(function(key) {
        receiver[key] = supplier[key];
    });

    return receiver;
}
function EreignisZiel(){
}
EreignisZiel.prototype ={
constructor: EreignisZiel,
sage: function(wort){
console.log(wort);
},
};
let meinObjekt = {};
mixin(meinObjekt, EreignisZiel.prototype);
meinObjekt.sage("Hallo"); // Ausgabe: Hallo
&lt;!--index_931.html --&gt;</code></pre>
<p>Im nächsten Beispiel sehen Sie, dass die Methode assign() die Aufgabe der 
selbstgeschriebenen Methode mixin übernimmt. Sie müssen ein Mixin nicht 
mehr selbst programmieren. ECMAScript 6 bietet Ihnen dies von Hause aus.</p>
<pre><code>function EreignisZiel(){
}
EreignisZiel.prototype ={
constructor: EreignisZiel,
sage: function(wort){
console.log(wort);
},
};
let meinObjekt = {};
Object.assign(meinObjekt, EreignisZiel.prototype);
meinObjekt.sage("Hallo"); // Ausgabe: Hallo
&lt;!--index_931a.html --&gt;</code></pre>
<p>Achtung überschreiben.</p>
<pre><code>let meinObjekt = {};
Object.assign(meinObjekt, 
{id: "1"},
{id: "2"}
);
console.log(meinObjekt.id); // Ausgabe: 2
&lt;!--index_931b.html --&gt;</code></pre>
<p>Nur der Wert wird zugewiesen, nicht die Methode.</p>
<pre><code>let meinObjekt = {};
Object.assign(meinObjekt, 
{get id() {return "1"}},
{get id() {return "2"}}
);
console.log(meinObjekt.id); // Ausgabe: 2
console.log(meinObjekt.get); // Ausgabe: undefined
&lt;!--index_931c.html --&gt;</code></pre>
<h2 id="duplicate-objekt-literals">Duplicate Objekt literals</h2>
<p>Mit ECMAScript 6 darf man in einem Objekt-Literal eine Eigenschaft mit dem 
gleichen Namen mehrmals einfügen. Zum Beispiel so wie im folgenden 
Programmcode.</p>
<pre><code>"use strict";
let meinObjekt = {
    id: "1",
    id: "2"
};
console.log(meinObjekt.id); // Ausgabe: 2
&lt;!--index_931c.html --&gt;</code></pre>
<p>In ECMAScript 5 wurde ein Syntax-Fehler gemeldet, wenn ein gleicher Name 
mehrmals in einem Objekt-Literal vorkam.</p>
<h2 id="own-properie-enumeration">Own Properie enumeration</h2>
<p>ECMAScript 6 legt die Reihenfolge, in der Eigenschaften von Objekten aufgelistet 
werden fest. Diese Funktion erscheint auf den ersten Blick unwichtig. Sie sollten 
diese Funktion aber im Hinterkopf behalten. Es gibt Software, die eine bestimmte 
Reihenfolge in der Auflistung von Eigenschaften voraussetzt. ECMAScript 6 bietet 
eine Reihenfolge, auf die sich andere Programme verlassen können. 
Sehen Sie sich hierzu das nachfolgende Beispiel an.</p>
<pre><code>let meinObjekt = {
    a: 1,
    z: 1,
    w: 1,
    10: 1,
    9: 1,
    1: 1,
    5: 1,
    b: 1,
};
console.log(Object.getOwnPropertyNames(meinObjekt)); 
// Ausgabe: Array(8) [ "1", "5", "9", "10", "a", "z", "w", "b" ]
&lt;!--index_930.html --&gt;</code></pre>
<p>Die Sortierung erfolgt nach folgendenden Regeln:</p>
<ol>
<li>Alle Zahlen in aufsteigender Reihenfolge.</li>
<li>Alle Strings in der Reihenfolge in der diese zum Objekt hinzugefügt wurden.</li>
<li>Alle Symbole in der Reihenfolge in der diese zum Objekt hinzugefügt wurden.</li>
</ol>
<h2 id="verbesserungen-fur-prototypen">Verbesserungen für Prototypen</h2>
<h3 id="einen-prototyp-andern">Einen Prototyp ändern</h3>
<p>Mit ECMAScript 6 kann man Prototyp ändern 
<code>Object.setPrototypeOf();</code></p>
<pre><code>let mensch = { getGruss(){ return "Hallo";}};
let hund = { getGruss(){ return "Wauwau";}};
let frau = Object.create(mensch);
console.log(frau.getGruss()); // Ausgabe: Hallo
console.log(Object.getPrototypeOf(frau) === mensch); // Ausgabe: true
Object.setPrototypeOf(frau, hund);
console.log(frau.getGruss()); // Ausgabe: Hallo
console.log(Object.getPrototypeOf(frau) === hund); // Ausgabe: true
console.log(Object.getPrototypeOf(frau) === mensch); // Ausgabe: false
&lt;!--index_929.html --&gt;</code></pre>
<h3 id="leicherterer-zugriff-mit-super">Leicherterer Zugriff mit super</h3>
<p>Dieses Beispiel nutzt Vererbung. </p>
<pre><code>&lt;!--index_928.html --&gt;</code></pre>
<p>Die Einführung von <code>super</code> vereinfacht dieses Beispiel</p>
<pre><code>&lt;!--index_928a.html --&gt;</code></pre>
<p>Aber: Syntax error bei verkürzter Sytnax:
<a href="https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Functions/Methoden_Definitionen">https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Functions/Methoden_Definitionen</a></p>
<pre><code>&lt;!--index_928b.html --&gt;</code></pre>
<p><code>super</code> ist bei Mehrfachvererbung wirlich hilfreich. Alles funktioniert dann nicht mehr.</p>
<pre><code>&lt;!--index_928c.html --&gt;</code></pre>
<p>Mit super klappt das aber dann.</p>
<pre><code>&lt;!--index_928d.html --&gt;</code></pre>
<h2 id="eine-formale-methodendefinition">Eine formale Methodendefinition</h2>
<pre><code>&lt;!--index_927.html --&gt;</code></pre>
<p><code>super.getGruss()</code> ist äquivalent zu <code>mensch.getGruss.call(this)</code></p>
<p>Diese Funktion ist keine Methode.</p>
<pre><code>function getGruss(){ 
return "Hi";
}</code></pre>
<blockquote>
<p><strong>Achtung:</strong></p>
</blockquote>
<h2 id="diesem-kapitel-haben-wir">In diesem Kapitel haben wir ...</h2>
<p>xxx</p>
<p>todo <a href="https://github.com/woota/FE-training-examples/blob/master/es6/4.%20Arrow-Functions.md">https://github.com/woota/FE-training-examples/blob/master/es6/4.%20Arrow-Functions.md</a></p>
<div class="footnotes">
<hr />
<ol>
</ol>
</div><h1 id="ecmascript-6-destrukturierende-zuweisung">ECMAScript 6 - Destrukturierende Zuweisung</h1>
<p><a href="#" id="DestrukturierendeZuweisung"></a></p>
<h2 id="diesem-kapitel-werden-wir">In diesem Kapitel werden wir …</h2>
<p>Zunächst zeige ich Ihnen, wie Sie 
Todo Meldungen immer mit Firefox</p>
<h2 id="warum-destrukturieren">Warum Destrukturieren</h2>
<p>Die destrukturierende Zuweisung ermöglicht es, Daten aus Arrays oder Objekten 
zu extrahieren, und zwar mit Hilfe einer Syntax, die der Konstruktion von 
Array- und Objekt-Literalen nachempfunden ist.
<a href="https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Operators/Destrukturierende_Zuweisung">https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Operators/Destrukturierende_Zuweisung</a></p>
<p>Mit ECMAScript 5 musste oft viel doppelter Text geschrieben werden.</p>
<pre><code>let farben = { 
rot: "#FF0000",
gruen: "#00FF00",
blau: "#0000FF"
};
let rot = farben.rot;
let gruen = farben.gruen;
let blau = farben.blau;

console.log(rot);
console.log(gruen);
console.log(blau);
&lt;!--index_926.html --&gt;</code></pre>
<h2 id="objekt-strukturierung">Objekt Strukturierung</h2>
<p>Anstelle von </p>
<pre><code>let rot = farben.rot;
let gruen = farben.gruen;
let blau = farben.blau;</code></pre>
<p>reicht mit ECMAScript 6 die Zeile</p>
<pre><code>let {rot, gruen, blau} = farben;</code></pre>
<pre><code>let farben = { 
rot: "#FF0000",
gruen: "#00FF00",
blau: "#0000FF"
};
let {rot, gruen, blau} = farben;

console.log(rot);
console.log(gruen);
console.log(blau);
&lt;!--index_926a.html --&gt;</code></pre>
<blockquote>
<p>Initialisieren nicht vergessen!</p>
</blockquote>
<pre><code>...
let {rot, gruen, blau}; 
// Ausgabe: SyntaxError: missing = in destructuring declaration
&lt;!--index_926b.html --&gt;</code></pre>
<h3 id="zuweisung">Zuweisung</h3>
<p>Nicht nur bei der Initialisierung eines Objektes gibt es Verbesserungen. Auch 
die Zuweisung eines Wertes zu einer Eigenschaft ist mit 
ECMAScript 6 unkomplizierter. </p>
<pre><code>&lt;!--index_925.html --&gt;</code></pre>
<p>Das geht auch in einer Funktion.</p>
<pre><code>&lt;!--index_925b.html --&gt;</code></pre>
<blockquote>
<p>Achtung: Es gibt einen Fehler, wenn die Zuweisung einmal <code>null</code> ist.</p>
</blockquote>
<h3 id="standardwerte">Standardwerte</h3>
<p>Manchmal kommt es vor, dass ein Wert nicht bestimmt ist. Deshalb ist es gut, 
dass bei auch bei destrukturierender Zuweisung mit Standardwerten arbeiten kann. </p>
<p>Ohne einen Standardwert anzugeben würde eine Variable nicht definiert werden.</p>
<pre><code>
&lt;!--index_924.html --&gt;</code></pre>
<p>Mit Standardwerten kann man dieses Problem umgehen - wie das geht zeigt das 
nächste Beispiel.</p>
<pre><code>let farben = { 
rot: "#FF0000",
gruen: "#00FF00",
};

let {rot = "#FF1111", gruen = "#1111FF", blau = "#0000FF"} = farben;

console.log(rot); // Ausgabe: #FF0000
console.log(gruen); // Ausgabe: #00FF00
console.log(blau); // Ausgabe: undefined
&lt;!--index_924a.html --&gt;</code></pre>
<h3 id="lokale-variablen">Lokale Variablen</h3>
<p>Bisher waren beim destrukturieren die korrespondierenden 
Variablennamen immer gleich. Das kann aber auch einmal anders sein. Die 
Namen können abweichen. Deshalb ist es gut, dass es hierfür eine Lösung in der 
Syntax gibt.</p>
<pre><code>
&lt;!--index_923.html --&gt;</code></pre>
<p>Und lokalen Variblen können Sie auch in Verbindung mit Standardvariablen 
einsetzen. Sehen Sie sich dazu das nachfolgende Beispiel an.</p>
<pre><code>
&lt;!--index_923a.html --&gt;

### Verschachtelungen

</code></pre>
<p>let farben = { 
farbcode: {
rot: {
hellrot: "#FFEEEEE",
dunkelrot: "#FF0000",
}
},
};
let {farbcode: {rot}}  = farben;
console.log(rot.hellrot); // Ausgabe: #FFEEEE
console.log(rot.dunkelrot); // Ausgabe: #FF0000
&lt;!--index_922.html --&gt;</p>
<p>Auch das Vergeben eines neuen Variablennamens ist mögliche.</p>
<pre><code>let farben = { 
farbcode: {
rot: {
hellrot: "#FFEEEEE",
dunkelrot: "#FF0000",
}
},
};
let {farbcode: {rot: farbcodesrot}}  = farben;
console.log(farbcodesrot.hellrot); // Ausgabe: #FFEEEE
console.log(farbcodesrot.dunkelrot); // Ausgabe: #FF0000
&lt;!--index_922a.html --&gt;

## Array Strukturierung


</code></pre>
<p>let farben = ["rot", "gruen", "blau"];
let [farbe1, farbe2]  = farben;
console.log(farbe1); // Ausgabe: rot
console.log(farbe2); // Ausgabe: gruen
&lt;!--index_922.html --&gt;</p>
<p>Sie können einzelne Array Elemente innerhalb des Arrays auswählen.</p>
<pre><code>let farben = ["rot", "gruen", "blau"];
let [, , farbe3]  = farben;
console.log(farbe3); // Ausgabe: blau
&lt;!--index_921a.html --&gt;

Schon vorhandene Variablen können verwendet werden.
</code></pre>
<p>let farben = ["rot", "gruen", "blau"];
let [, , farbe3]  = farben;
console.log(farbe3); // Ausgabe: rot
&lt;!--index_921b.html --&gt;</p>
<h3 id="zuweisung">Zuweisung</h3>
<p><a href="https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Operators/Destrukturierende_Zuweisung#Variablen_tauschen">https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Operators/Destrukturierende_Zuweisung#Variablen_tauschen</a>
Die destrukturiende Zuweisung kann auch zum Tauschen von Variablenwerten 
verwendet werden.</p>
<p>Bisher</p>
<pre><code>let erster = "Astrid";
let zweiter = "Elmar";
let helfer;
console.log(erster); // Ausgabe: Astrid
console.log(zweiter); // Ausgabe: Elmar
helfer = erster;
erster = zweiter;
zweiter = helfer;
console.log(erster); // Ausgabe: Elmar
&lt;!--index_920.html --&gt;</code></pre>
<p>Neu</p>
<pre><code>let erster = "Astrid";
let zweiter = "Elmar";
console.log(erster); // Ausgabe: Astrid
console.log(zweiter); // Ausgabe: Elmar
[erster, zweiter] = [zweiter, erster];
console.log(erster); // Ausgabe: Elmar
console.log(zweiter); // Ausgabe: Astrid
&lt;!--index_920a.html --&gt;</code></pre>
<h3 id="standardwerte">Standardwerte</h3>
<h3 id="lokale-variablen">Lokale Variablen</h3>
<h3 id="rest-items">Rest Items</h3>
<h2 id="gemischte-strukturierung">Gemischte Strukturierung</h2>
<h2 id="parameter-strukturierung">Parameter Strukturierung</h2>
<h3 id="notwendige-parameter">Notwendige Parameter</h3>
<h3 id="standardwerte">Standardwerte</h3>
<blockquote>
<p><strong>Achtung:</strong></p>
</blockquote>
<h2 id="diesem-kapitel-haben-wir">In diesem Kapitel haben wir ...</h2>
<p>xxx</p>
<p>todo <a href="https://github.com/woota/FE-training-examples/blob/master/es6/4.%20Arrow-Functions.md">https://github.com/woota/FE-training-examples/blob/master/es6/4.%20Arrow-Functions.md</a></p>
<div class="footnotes">
<hr />
<ol>
</ol>
</div><h1 id="auf-wiedersehen">Auf Wiedersehen</h1>
<p>Ich hoffe, dass Ihnen der Rundgang durch LeafletJs gefallen hat und Sie jede 
Menge für sich mitnehmen konnten.</p></html>